<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-tutorials/hacker-news-scraper" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.3">
<title data-rh="true">Hacker News Scraper | Pathom 3</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://pathom3.wsscode.com/docs/tutorials/hacker-news-scraper"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Hacker News Scraper | Pathom 3"><meta data-rh="true" name="description" content="In this tutorial, we are going to write a scraper to extract information from hacker"><meta data-rh="true" property="og:description" content="In this tutorial, we are going to write a scraper to extract information from hacker"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://pathom3.wsscode.com/docs/tutorials/hacker-news-scraper"><link data-rh="true" rel="alternate" href="https://pathom3.wsscode.com/docs/tutorials/hacker-news-scraper" hreflang="en"><link data-rh="true" rel="alternate" href="https://pathom3.wsscode.com/docs/tutorials/hacker-news-scraper" hreflang="x-default"><link data-rh="true" rel="preconnect" href="https://8YW0ZACTDN-dsn.algolia.net" crossorigin="anonymous"><link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://www.googletagmanager.com">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-GZFCYV0DXN"></script>
<script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-GZFCYV0DXN",{})</script>


<link rel="search" type="application/opensearchdescription+xml" title="Pathom 3" href="/opensearch.xml"><link rel="stylesheet" href="/assets/css/styles.5e9cce91.css">
<link rel="preload" href="/assets/js/runtime~main.7be6ae2a.js" as="script">
<link rel="preload" href="/assets/js/main.670c6fc5.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"dark")}()</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/icon_64x64.png" alt="Pathom 3" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/icon_64x64.png" alt="Pathom 3" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">Pathom 3</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/">Docs</a><a href="https://blog.wsscode.com" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><a class="navbar__item navbar__link" href="/media">Media</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/wilkerlucio/pathom3" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="searchBox_ZlJk"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebarViewport_Xe31"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/">Getting Started</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/tutorial">Pathom Tutorial</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/nouns">Nouns</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/resolvers">Using Pathom</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/indexes">How Pathom Works</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/integrations/graphql">Integrations</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/docs/tutorials/hacker-news-scraper">Tutorials</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/tutorials/hacker-news-scraper">Hacker News Scraper</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/tutorials/serverless-pathom-gcf">Serverless Pathom with GCF</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/tutorials/babashka">Scripting with Babashka</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/tutorials/graphql-integration">GraphQL Integration</a></li></ul></li></ul></nav></div></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">Tutorials</span><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Hacker News Scraper</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Hacker News Scraper</h1></header><p>In this tutorial, we are going to write a scraper to extract information from hacker
news pages using Pathom.</p><p>Pathom enables declarative programming for data processing.</p><p>Using Pathom, we will map out the data from Hacker News in attributes, and then we use
this mapping in various ways to query information.</p><p>This scraper will be capable of:</p><ul><li>Listing hacker news pages: news, past, ask</li><li>Read user data</li><li>Read comments from items</li><li>Navigate on pagination</li></ul><p>Let&#x27;s start!</p><h2 id="attribute-mapping">Attribute mapping</h2><p>The first step is to make names for every attribute we want to handle.</p><p>Here is a quick guide you can follow to help in this process:</p><ol><li>Pick a general prefix, usually the product/service name. For this case, I&#x27;ll pick: <code>hacker-news</code>.</li><li>For data points, add some entity context in the name. In the case of Hacker News, I see they call it <code>item</code>.</li><li>If you mean to read collections, give each collection a name.</li></ol><admonition type="note"><p>If you are developing a product for a company, use the company name for step one.
Avoid having short names like <code>:user/name</code> since they have a higher collision chance.
This makes your names much harder to integrate with other names.</p></admonition><p>Let&#x27;s see what are the interesting data points to extract from the Hacker News front
page:</p><div class="pathom-diagram"><p>  <img alt="Front Page Mapping" src="/assets/images/front-page-mapping-d5349096bcb336297a94210c1ff2a0d9.png" width="1197" height="648"></p></div><p>The circle cursors point to visible points of data. The open diamond means the data
is hidden (inside the markup).</p><p>I used the name <code>:hacker-news.page/news</code> to name the collection of items for this page.</p><p>Here is a text version of all the declared attributes:</p><pre><code class="language-clojure">; item attributes
:hacker-news.item/age
:hacker-news.item/author-name
:hacker-news.item/id
:hacker-news.item/comments-count
:hacker-news.item/score
:hacker-news.item/rank-in-page
:hacker-news.item/source
:hacker-news.item/title
:hacker-news.item/url

; news collection
:hacker-news.page/news
</code></pre><h2 id="reading-the-news-page">Reading the news page</h2><p>For the implementation, I&#x27;ll use the <a href="https://github.com/davidsantiago/hickory">Hickory</a> library to parse the HTML and extract
the data.</p><p>To start, we need to explore and figure the code to extract the information fragments
from the HTML page.</p><p>I like to start reading the raw HTML and saving it on a <code>defonce</code>, so I can keep reloading
the REPL while has a cached version of sample data:</p><pre><code class="language-clojure">(ns com.wsscode.pathom3.docs.demos.tutorials.hacker-news-scrapper)

(defonce sample-html (slurp (str &quot;https://news.ycombinator.com/news&quot;)))
</code></pre><p>It&#x27;s time to learn about the HTML structure of Hacker News page. I like to use the
Chrome inspector to navigate. I can see there is a table with the class <code>itemlist</code>
wrapping the item elements.</p><div class="pathom-diagram"><p>  <img alt="Front Page Mapping" src="/assets/images/inspect-container-649f80cfd60a317b395eb5fbacdd95cb.png" width="1133" height="656"></p></div><h3 id="finding-the-items">Finding the items</h3><p>I&#x27;ll start this query using our data and Hickory and try it on the REPL, I suggest
you follow along in your REPL:</p><pre><code class="language-clojure">(ns com.wsscode.pathom3.docs.demos.tutorials.hacker-news-scrapper
  (:require [hickory.core :as hc]
            [hickory.select :as hs]))

(defonce sample-html (slurp (str &quot;https://news.ycombinator.com/news&quot;)))

(comment
  ; navigate to table element
  (-&gt;&gt; sample-html
       (hc/parse)
       (hc/as-hickory)
       (hs/select (hs/class &quot;itemlist&quot;))
       first))
</code></pre><p>Now we can extract the rows out. Hacker News doesn&#x27;t make it straight forward. When I
look at the rows, I see each item uses two table rows. Then it has a spacer row between
the next two with the class <code>spacer</code>. To add more details, there is a
different row with the class <code>morespace</code> in the end.</p><p>To deal with this, we are going to query for rows, removing the ones with the class <code>spacer</code>
or <code>morespace</code>.</p><p>This is how we can do it with Hickory:</p><pre><code class="language-clojure">(comment
  (-&gt;&gt; sample-html
       (hc/parse)
       (hc/as-hickory)
       (hs/select (hs/class &quot;itemlist&quot;))
       first
       (hs/select (hs/and
                    (hs/tag &quot;tr&quot;)
                    (hs/not (hs/or
                              (hs/class &quot;spacer&quot;)
                              (hs/class &quot;morespace&quot;)))))
       (partition 2)
       (mapv #(hash-map :type :element :tag :tbody :content (vec %)))))
</code></pre><p>Now we have a collection where each item represents a row in Hacker News.</p><admonition type="note"><p>After the <code>partition</code> the <code>mapv</code> is making a fake element for Hickory, this way we
can treat the two rows as a single element for querying in.</p></admonition><h3 id="read-item-details">Read item details</h3><p>Now for each item, we need to extract the attributes we want. Here are a few helpers
we will use for it:</p><pre><code class="language-clojure">(defn find-text
  &quot;Given an element, traverse the contents until it reaches some text.&quot;
  [el]
  (loop [item (first (:content el))]
    (if (string? item)
      item
      (if-let [next (some-&gt; item :content first)]
        (recur next)
        nil))))

(defn class-text
  &quot;Get the text for a given element that matches a css class.&quot;
  [el class]
  (-&gt;&gt; (hs/select (hs/class class) el)
       first
       (find-text)))

(defn select-number
  &quot;Extract the first integer from a string.&quot;
  [x]
  (if-let [[_ n] (re-find #&quot;(\d+)&quot; (str x))]
    (Integer/parseInt n)
    0))
</code></pre><p>Here is a function to extract the data points we mentioned at start from each item:</p><pre><code class="language-clojure">(defn extract-item-from-hickory [el]
  {:hacker-news.item/age            (class-text el &quot;age&quot;)
   :hacker-news.item/author-name    (class-text el &quot;hnuser&quot;)
   :hacker-news.item/comments-count (-&gt;&gt; (hs/select (hs/find-in-text #&quot;comments$&quot;) el)
                                         first
                                         (find-text)
                                         (select-number))
   :hacker-news.item/score          (select-number (class-text el &quot;score&quot;))
   :hacker-news.item/id             (-&gt;&gt; el :content first :attrs :id)
   :hacker-news.item/rank-in-page   (select-number (class-text el &quot;rank&quot;))
   :hacker-news.item/source         (class-text el &quot;sitestr&quot;)
   :hacker-news.item/title          (class-text el &quot;titlelink&quot;)
   :hacker-news.item/url            (-&gt;&gt; (hs/select (hs/class &quot;titlelink&quot;) el)
                                         first :attrs :href)})
</code></pre><p>Let&#x27;s use it to extract the data from our previous process:</p><pre><code class="language-clojure">(comment
  (-&gt;&gt; sample-html
       (hc/parse)
       (hc/as-hickory)
       (hs/select (hs/class &quot;itemlist&quot;))
       first
       (hs/select (hs/and
                    (hs/tag &quot;tr&quot;)
                    (hs/not (hs/or
                              (hs/class &quot;spacer&quot;)
                              (hs/class &quot;morespace&quot;)))))
       (partition 2)
       (mapv #(hash-map :type :element :tag :tbody :content (vec %)))
       (mapv extract-item-from-hickory)))
</code></pre><p>Now you should see the nice plain data in the output, with one map for each
item entry.</p><h2 id="make-a-resolver">Make a resolver</h2><p>Time to introduce Pathom, now I&#x27;m going to turn that exploration code in a resolver:</p><pre><code class="language-clojure" metastring="{2-4,47-87}">(ns com.wsscode.pathom3.docs.demos.tutorials.hacker-news-scrapper
  (:require [com.wsscode.pathom3.connect.indexes :as pci]
            [com.wsscode.pathom3.connect.operation :as pco]
            [com.wsscode.pathom3.interface.eql :as p.eql]
            [hickory.core :as hc]
            [hickory.select :as hs]))

(defn find-text
  &quot;Given an element, traverse the contents until it reaches some text.&quot;
  [el]
  (loop [item (first (:content el))]
    (if (string? item)
      item
      (if-let [next (some-&gt; item :content first)]
        (recur next)
        nil))))

(defn class-text
  &quot;Get the text for a given element that matches a css class.&quot;
  [el class]
  (-&gt;&gt; (hs/select (hs/class class) el)
       first
       (find-text)))

(defn select-number
  &quot;Extract the first integer from a string.&quot;
  [x]
  (if-let [[_ n] (re-find #&quot;(\d+)&quot; (str x))]
    (Integer/parseInt n)
    0))

(defn extract-item-from-hickory [el]
  {:hacker-news.item/age            (class-text el &quot;age&quot;)
   :hacker-news.item/author-name    (class-text el &quot;hnuser&quot;)
   :hacker-news.item/comments-count (-&gt;&gt; (hs/select (hs/find-in-text #&quot;comments$&quot;) el)
                                         first
                                         (find-text)
                                         (select-number))
   :hacker-news.item/score          (select-number (class-text el &quot;score&quot;))
   :hacker-news.item/id             (-&gt;&gt; el :content first :attrs :id)
   :hacker-news.item/rank-in-page   (select-number (class-text el &quot;rank&quot;))
   :hacker-news.item/source         (class-text el &quot;sitestr&quot;)
   :hacker-news.item/title          (class-text el &quot;storylink&quot;)
   :hacker-news.item/url            (-&gt;&gt; (hs/select (hs/class &quot;storylink&quot;) el)
                                         first :attrs :href)})

(pco/defresolver news-page-html-string []
  {:hacker-news.page/news-raw-html
   (slurp &quot;https://news.ycombinator.com/news&quot;)})

(pco/defresolver news-page [{:hacker-news.page/keys [news-raw-html]}]
  {::pco/output
   [{:hacker-news.page/news
     [:hacker-news.item/age
      :hacker-news.item/author-name
      :hacker-news.item/id
      :hacker-news.item/comments-count
      :hacker-news.item/score
      :hacker-news.item/rank-in-page
      :hacker-news.item/source
      :hacker-news.item/title
      :hacker-news.item/url]}]}
  {:hacker-news.page/news
   (-&gt;&gt; news-raw-html
        (hc/parse)
        (hc/as-hickory)
        (hs/select (hs/class &quot;itemlist&quot;))
        first
        (hs/select (hs/and
                     (hs/tag &quot;tr&quot;)
                     (hs/not (hs/or
                               (hs/class &quot;spacer&quot;)
                               (hs/class &quot;morespace&quot;)))))
        (partition 2)
        (mapv #(hash-map :type :element :tag :tbody :content (vec %)))
        (mapv extract-item-from-hickory))})

(def env
  (pci/register
    [news-page-html-string
     news-page]))

(comment
  ; get the title of all the news
  (p.eql/process env
    [{:hacker-news.page/news
      [:hacker-news.item/title]}]))
</code></pre><p>Not much yet, but we gained the ability to filter pieces of the results.</p><admonition type="tip"><p>Some editors like <a href="https://cursive-ide.com/">Cursive</a> do highlight keywords when your
cursor is over them. You can use this indication to see the inputs connecting with
outputs in the editor.</p></admonition><h3 id="caching-the-request-for-development">Caching the request for development</h3><p>When we run the process now, it requests hacker news every time. For development
it&#x27;s useful if we can cache that to have a faster iteration.</p><p>You may have noticed I used a separated resolver to fetch the HTML string. We can make
this resolver use a durable cache to speed up the iteration:</p><pre><code class="language-clojure">(pco/defresolver news-page-html-string []
  ; define a custom cache store for this resolver
  {::pco/cache-store ::durable-cache*}
  {:hacker-news.page/news-raw-html
   (slurp &quot;https://news.ycombinator.com/news&quot;)})

; defonce to have a durable cache, an atom with a map is a valid empty cache
(defonce cache* (atom {}))

(def env
  ; add our cache to the environment
  (-&gt; {::durable-cache* cache*}
      (pci/register
        [news-page-html-string
         news-page])))
</code></pre><p>Now, if you keep running that expression, it only does the IO on the first time.</p><admonition type="tip"><p>To clear the cache, run <code>(reset! cache* {})</code> in the REPL.</p></admonition><h2 id="traversing-pagination">Traversing pagination</h2><p>So far, we only read the first page of the news, but there is a <code>More</code> button at the
end. Now we are going to scan through these pages.</p><p>First we need to adapt the resolver that loads the page html to accept a custom URL
for it:</p><pre><code class="language-clojure">(pco/defresolver news-page-html-string [{:hacker-news.page/keys [news-page-url]}]
  {::pco/cache-store ::durable-cache*
   ::pco/input       [(pco/? :hacker-news.page/news-page-url)]}
  {:hacker-news.page/news-raw-html
   (slurp (or news-page-url &quot;https://news.ycombinator.com/news&quot;))})
</code></pre><p>I used an <a href="/docs/resolvers#optional-inputs">optional input</a> named <code>:hacker-news.page/news-page-url</code> to allow the
customization, but still have a default.</p><p>To provide the data with the URL for the next page, I&#x27;ll add a new resolver. This resolver
will expose the attribute <code>:hacker-news.page/news-next-page</code> that contains the key
<code>:hacker-news.page/news-page-url</code>:</p><pre><code class="language-clojure">(pco/defresolver news-next-page [{:hacker-news.page/keys [news-raw-html]}]
  {::pco/output
   [{:hacker-news.page/news-next-page
     [:hacker-news.page/news-page-url]}]}
  (let [link (some-&gt;&gt; news-raw-html hc/parse hc/as-hickory
               (hs/select (hs/class &quot;morelink&quot;))
               first :attrs :href)]
    (if link
      {:hacker-news.page/news-next-page
       {:hacker-news.page/news-page-url
        (str &quot;https://news.ycombinator.com/&quot; link)}})))
</code></pre><admonition type="tip"><p>You can look at this resolver as an implementation of a linked list. The attribute
<code>:hacker-news.page/news-next-page</code> is a link to the next page item. In terms of Pathom,
we make that happen by providing the <code>:hacker-news.page/news-page-url</code> in that context, which can navigate
to the next <code>:hacker-news.page/news-next-page</code> and so on...</p></admonition><p>I check if there is a <code>More</code> link. Otherwise, we don&#x27;t return any data to tell Pathom
this is unavailable.</p><p>You may notice we now have two resolvers that get the HTML string for the news page
and parse it. Each resolver is doing its parsing. We can make them share this
by breaking this step into a new resolver.</p><pre><code class="language-clojure" metastring="{1-6,8-9,34-35}">; get the html string and compute hickory
(pco/defresolver news-page-hickory [{:hacker-news.page/keys [news-raw-html]}]
  {:hacker-news.page/news-hickory
   (-&gt; news-raw-html
       (hc/parse)
       (hc/as-hickory))})

; news page now uses the hickory
(pco/defresolver news-page [{:hacker-news.page/keys [news-hickory]}]
  {::pco/output
   [{:hacker-news.page/news
     [:hacker-news.item/age
      :hacker-news.item/author-name
      :hacker-news.item/id
      :hacker-news.item/comments-count
      :hacker-news.item/score
      :hacker-news.item/rank-in-page
      :hacker-news.item/source
      :hacker-news.item/title
      :hacker-news.item/url]}]}
  {:hacker-news.page/news
   (-&gt;&gt; news-hickory
        (hs/select (hs/class &quot;itemlist&quot;))
        first
        (hs/select (hs/and
                     (hs/tag &quot;tr&quot;)
                     (hs/not (hs/or
                               (hs/class &quot;spacer&quot;)
                               (hs/class &quot;morespace&quot;)))))
        (partition 2)
        (mapv #(hash-map :type :element :tag :tbody :content (vec %)))
        (mapv extract-item-from-hickory))})

; same for next page
(pco/defresolver news-next-page [{:hacker-news.page/keys [news-hickory]}]
  {::pco/output
   [{:hacker-news.page/news-next-page
     [:hacker-news.page/news-page-url]}]}

  (let [link (some-&gt;&gt; news-hickory
               (hs/select (hs/class &quot;morelink&quot;))
               first :attrs :href)]
    (if link
      {:hacker-news.page/news-next-page
       {:hacker-news.page/news-page-url
        (str &quot;https://news.ycombinator.com/&quot; link)}})))
</code></pre><p>This is a crucial design choice when you write Pathom resolvers. How much you want
to break, as you add more resolvers, you expand the connection points to other resolvers.</p><p>In general, it is a good practice to keep spread, but it&#x27;s fine to provide many items
in a resolver when they share a close process. This reduces the amount of work Pathom
has to do to integrate.</p><p>Let&#x27;s play with our new resolvers:</p><pre><code class="language-clojure" metastring="{6,8}">; remember to update env to include all resolvers
(def env
  (-&gt; {::durable-cache* cache*}
      (pci/register
        [news-page-html-string
         news-page-hickory
         news-page
         news-next-page])))

(comment
  ; get titles from first and second page
  (p.eql/process env
    [{:hacker-news.page/news
      [:hacker-news.item/title]}
     {:hacker-news.page/news-next-page
      [{:hacker-news.page/news
        [:hacker-news.item/title]}]}]))
</code></pre><p>Notice the query inside <code>:hacker-news.page/news-next-page</code> is the same used in the
parent query. For this we can use recursive queries, let&#x27;s say we want to pull the
next three pages:</p><pre><code class="language-clojure">(comment
  (p.eql/process env
    [{:hacker-news.page/news
      [:hacker-news.item/title]}
     ; recurse bounded to 3 steps
     {:hacker-news.page/news-next-page 3}]))
</code></pre><p>How cool is that?! You may be saying now: ok, but that&#x27;s a weird tree output.</p><p>To flat the items out we can use <code>tree-seq</code>:</p><pre><code class="language-clojure">(comment
  (-&gt;&gt; (p.eql/process env
         [{:hacker-news.page/news
           [:hacker-news.item/title]}
          ; recurse bounded to 3 steps
          {:hacker-news.page/news-next-page 3}])
       (tree-seq :hacker-news.page/news-next-page
         ; we need vector at the end because tree-seq expects children to be a collection
         (comp vector :hacker-news.page/news-next-page))
       ; mapcat the news to have a single flat list
       (into [] (mapcat :hacker-news.page/news))))
</code></pre><admonition type="note"><p>Recursive queries can be numbers (bounded) or a symbol ... (unbounded). If you use the
unbounded, it will pull pages until Hacker News is over with them. During the time
I tested there were 21 pages. If you try, it may take some time to finish.</p></admonition><p>Pathom also supports <a href="/docs/resolvers#nested-inputs">nested inputs</a>, this means we can create a resolver to make that
same process we did with the query before:</p><pre><code class="language-clojure" metastring="{12-13}">(pco/defresolver all-news-pages [input]
  {::pco/input  [{:hacker-news.page/news
                  [:hacker-news.item/age
                   :hacker-news.item/author-name
                   :hacker-news.item/id
                   :hacker-news.item/comments-count
                   :hacker-news.item/score
                   :hacker-news.item/rank-in-page
                   :hacker-news.item/source
                   :hacker-news.item/title
                   :hacker-news.item/url]}
                 ; note the recursive query here
                 {:hacker-news.page/news-next-page &#x27;...}]
   ::pco/output [{:hacker-news.page/news-all-pages
                  [:hacker-news.item/age
                   :hacker-news.item/author-name
                   :hacker-news.item/id
                   :hacker-news.item/comments-count
                   :hacker-news.item/score
                   :hacker-news.item/rank-in-page
                   :hacker-news.item/source
                   :hacker-news.item/title
                   :hacker-news.item/url]}]}
  {:hacker-news.page/news-all-pages
   (-&gt;&gt; input
        (tree-seq :hacker-news.page/news-next-page
          (comp vector :hacker-news.page/news-next-page))
        (into [] (mapcat :hacker-news.page/news)))})
</code></pre><p>Now we can, for example, make this query to read all titles in news, in all pages:</p><pre><code class="language-clojure">(comment
  ; this can take a while
  (-&gt;&gt; (p.eql/process env
         [{:hacker-news.page/news-all-pages
           [:hacker-news.item/title]}])))
</code></pre><h2 id="read-user-data">Read user data</h2><p>Let&#x27;s look at the user page this time:</p><div class="pathom-diagram"><p>  <img alt="User Page Mapping" src="/assets/images/user-page-mapping-3391c9719602dcc5e58a29782de36eeb.png" width="668" height="285"></p></div><p>Similar to before, but this time we require some user id to load the page. The arrows
show that the same attribute we read on the page as <code>:hacker-news.user/id</code> is used
in the URL to load the page.</p><p>Here are the resolvers to parse this:</p><pre><code class="language-clojure">(pco/defresolver user-data-hickory [{:keys [hacker-news.user/id]}]
  ; also use the durable cache here
  {::pco/cache-store ::durable-cache*}
  {:hacker-news.page/user-hickory
   (some-&gt; (slurp (str &quot;https://news.ycombinator.com/user?id=&quot; id))
     hc/parse hc/as-hickory)})

(pco/defresolver user-data [{:hacker-news.page/keys [user-hickory]}]
  {:hacker-news.user/karma
   (-&gt;&gt; user-hickory
        (hs/select
          (hs/and
            (hs/tag &quot;tr&quot;)
            (hs/has-child (hs/find-in-text #&quot;karma:&quot;))))
        first :content second :content select-number)

   :hacker-news.user/join-date
   (let [str (-&gt;&gt; user-hickory
                  (hs/select
                    (hs/and
                      (hs/tag &quot;tr&quot;)
                      (hs/has-child (hs/find-in-text #&quot;created:&quot;))))
                  first :content second :content first :attrs :href)
         [_ date] (re-find #&quot;(\d{4}-\d{2}-\d{2})&quot; str)]
     date)})
</code></pre><p>Note we also use the durable cache, so we can keep playing it. When I created this I
was hitting the same cache entry until I got the extraction code right.</p><admonition type="important"><p>You may have noticed that we now have two different attributes that mean user id.
We have <code>:hacker-news.item/author-name</code> and now <code>:hacker-news.user/id</code>. If we try to load the karma for the user in the HN item, it won&#x27;t be able to get there.</p><p>One idea is to change our previous resolver and rename <code>:hacker-news.item/author-name</code>
to <code>:hacker-news.user/id</code>. This would work, but this reduces the accuracy of this name
semantics. <code>:hacker-news.item/author-name</code> has a precise meaning. It&#x27;s the author&#x27;s
name in an item.</p><p>To reconcile this situation, we can create an <a href="/docs/built-in-resolvers#aliasing">alias-resolver</a>,
that allows Pathom to navigate from one name to another. This is what I&#x27;m going to
use next.</p><p>It&#x27;s also good to point out that aliases are directional. We are allowing
<code>:hacker-news.item/author-name</code> to be translated in <code>:hacker-news.user/id</code>, but not
the reverse.</p></admonition><p>Let&#x27;s see who has the most karma from the front-page:</p><pre><code class="language-clojure">; update env
(def env
  (-&gt; {::durable-cache* cache*}
      (pci/register
        [; alias the author name to id
         (pbir/alias-resolver :hacker-news.item/author-name :hacker-news.user/id)
         news-page-html-string
         news-page-hickory
         news-page
         news-next-page
         user-data-hickory
         user-data])))

(comment
  (-&gt;&gt; (p.eql/process env
         [{:hacker-news.page/news
           [:hacker-news.item/author-name
            :hacker-news.user/karma]}])
       :hacker-news.page/news
       (sort-by :hacker-news.user/karma #(compare %2 %))))
</code></pre><h2 id="read-comments">Read comments</h2><p>Let&#x27;s map the comments section:</p><div class="pathom-diagram"><p>  <img alt="Comments Page Mapping" src="/assets/images/comments-page-mapping-e0b023e3af3f972a5fd5e566a8739918.png" width="1065" height="899"></p></div><p>We can see at the top we have almost the same data as we did on the news list, except
the rank position (which makes sense since it&#x27;s relative to that page).</p><p>Let&#x27;s start writing a resolver that can read this information given some item id:</p><pre><code class="language-clojure">; load page as hickory, use our durable cache
(pco/defresolver item-page-hickory [{:hacker-news.item/keys [id]}]
  {::pco/cache-store ::durable-cache*}
  {:hacker-news.page/item-hickory
   (-&gt;&gt; (slurp (str &quot;https://news.ycombinator.com/item?id=&quot; id))
        hc/parse hc/as-hickory)})

(pco/defresolver item-data [{:hacker-news.page/keys [item-hickory]}]
  {::pco/output
   [:hacker-news.item/age
    :hacker-news.item/author-name
    :hacker-news.item/comments-count
    :hacker-news.item/score
    :hacker-news.item/source
    :hacker-news.item/title
    :hacker-news.item/url]}
  ; let&#x27;s re-use our same extraction function, fatitem class is the container at
  ; this page
  (extract-item-from-hickory (-&gt;&gt; (hs/select (hs/class &quot;fatitem&quot;) item-hickory)
                                  first)))
</code></pre><p>That&#x27;s easy enough—time for the comments.</p><p>By looking at the page we can see comments are nested, and altough this example isn&#x27;t
showing, they also support deep nesting.</p><p>Most of the time, the HTML will follow the structure of the data, but this isn&#x27;t the
case here.</p><p>Try inspecting the page. You will see they use a flat table and manually add the
spacings to convey the nesting.</p><p>This means we need to do more work to reconstruct the tree from a flat structure.</p><p>Let&#x27;s do that in parts. First, let&#x27;s extract it in a closer way to what we have: a flat structure. On top of the data I mentioned in the image, we now will
also add a <code>:hacker-news.comment/ident</code>, which tells us the row&#x27;s indentation level. Later I&#x27;ll use this to transform the list into a tree.</p><pre><code class="language-clojure">(defn comment-ident-level [el]
  (-&gt; (hs/select (hs/and (hs/tag &quot;img&quot;) (hs/attr &quot;src&quot; #{&quot;s.gif&quot;})) el)
      first :attrs :width select-number (/ 40)))

(defn extract-comment [el]
  {:hacker-news.comment/id          (-&gt; el :attrs :id)
   :hacker-news.comment/age         (class-text el &quot;age&quot;)
   :hacker-news.comment/author-name (class-text el &quot;hnuser&quot;)
   :hacker-news.comment/indent      (comment-ident-level el)
   :hacker-news.comment/content     (-&gt;&gt; (hs/select (hs/class &quot;comment&quot;) el)
                                         first :content (keep find-text) (str/join &quot;\n&quot;))})

(pco/defresolver item-comments-flat [{:hacker-news.page/keys [item-hickory]}]
  {::pco/output [{:hacker-news.item/comments-flat
                  [:hacker-news.comment/author-name
                   :hacker-news.comment/age
                   :hacker-news.comment/content
                   :hacker-news.comment/id
                   :hacker-news.comment/indent]}]}
  {:hacker-news.item/comments-flat
   (-&gt;&gt; item-hickory
        (hs/select (hs/class &quot;comtr&quot;))
        (mapv extract-comment))})
</code></pre><p>We can test that with (remember to add all resolvers to the env):</p><pre><code class="language-clojure">(comment
  ; get all comments author names
  (p.eql/process env
    {:hacker-news.item/id &quot;25733200&quot;}
    [{:hacker-news.item/comments-flat
      [:hacker-news.comment/author-name]}]))
</code></pre><p>Now it&#x27;s time to transform the list into a tree.</p><p>To think about this process, let&#x27;s use make up some example data and how it should be
transformed:</p><pre><code class="language-clojure">; first, visually, it looks like this:
; 1
; | 2
; | 3
; 4
; | 5
; | | 6

; we have a list like this, with ids and indentations, the rest of the data we can ignore
; for the purpose of this transformation
[{:id 1 :ident 0}
 {:id 2 :ident 1}
 {:id 3 :ident 1}
 {:id 4 :ident 0}
 {:id 5 :ident 1}
 {:id 6 :ident 2}]

; and our goal is to transform that into:
[{:id 1
  :children [{:id 2}
             {:id 3}]}
 {:id 4
  :children [{:id 5
              :children [{:id 6}]}]}]
</code></pre><p>To do this, we have to go over the list and remember past items. My idea to remember the
current level is: When it goes up, add an item to a stack. When it goes down, remove it from the
stack. The stack will contain the ids of the parent items. As I scan, I&#x27;ll also add
the items to a list, indexed by ID. This way, I can modify any item at any time with ease.</p><p>I decided it would be fun to use Pathom as part of this process too, and it&#x27;s nice the
things I discussed already feel like a graph.</p><p>This is the code:</p><pre><code class="language-clojure">(pco/defresolver item-comments [{:hacker-news.item/keys [comments-flat]}]
  {::pco/output
   [{:hacker-news.item/comments
     [:hacker-news.comment/author-name
      :hacker-news.comment/age
      :hacker-news.comment/content
      :hacker-news.comment/id
      {:hacker-news.comment/responses &#x27;...}]}]}
  (let [{:keys [roots index]}
        (-&gt;&gt; comments-flat
             (reduce
               (fn [{:keys [level prev] :as acc} {:hacker-news.comment/keys [id indent] :as comment}]
                 (let [{:keys [stack] :as acc} (cond-&gt; acc
                                                 (&gt; indent level)
                                                 (update :stack conj prev)

                                                 (&lt; indent level)
                                                 (update :stack pop))
                       stack-head (peek stack)]
                   (cond-&gt; acc
                     true
                     (-&gt; (update :index assoc id comment)
                         (assoc :level indent)
                         (assoc :prev id))

                     (zero? indent)
                     (update :roots conj comment)

                     (pos? indent)
                     (update-in [:index stack-head :hacker-news.comment/responses]
                       coll/vconj {:hacker-news.comment/id id}))))
               {:stack []
                :roots []
                :index {}
                :level 0
                :prev  nil}))]
    ; empty index when there are no comments
    (if (seq index)
      ; use pathom to transform the query in a tree
      (-&gt;&gt; (p.eql/process
             (pci/register [(pbir/static-table-resolver :hacker-news.comment/id index)
                            (pbir/constantly-resolver :roots roots)])
             [{:roots [:hacker-news.comment/author-name
                       :hacker-news.comment/age
                       :hacker-news.comment/content
                       :hacker-news.comment/id
                       {:hacker-news.comment/responses &#x27;...}]}])
           :roots
           ; always remember to wrap the sequence in the named output
           (hash-map :hacker-news.item/comments))
      {:hacker-news.item/comments []})))
</code></pre><p>Usage demo:</p><pre><code class="language-clojure">; lets recap what our env is like with all of the things
(def env
  (-&gt; {::durable-cache* cache*}
      (pci/register
        [(pbir/alias-resolver :hacker-news.item/author-name :hacker-news.user/id)
         ; add this new one to also alias from comment author name
         (pbir/alias-resolver :hacker-news.comment/author-name :hacker-news.user/id)
         news-page-html-string
         news-page-hickory
         news-page
         news-next-page
         all-news-pages
         user-data-hickory
         user-data
         item-page-hickory
         item-data
         item-comments-flat
         item-comments])))

(comment
  ; the same we did before, but this time we will only see the top level comments
  (p.eql/process env
    {:hacker-news.item/id &quot;25733200&quot;}
    [{:hacker-news.item/comments
      [:hacker-news.comment/author-name]}]))

(comment
  ; now, get the whole structured comments, and also include the karma of each user
  ; on it
  (p.eql/process env
    {:hacker-news.item/id &quot;25733200&quot;}
    [{:hacker-news.item/comments
      [:hacker-news.comment/author-name
       :hacker-news.user/karma
       {:hacker-news.comment/responses &#x27;...}]}]))

(comment
  ; WARNING: this will trigger a lot of requests, may take some time. Also, HN may
  ; throttle or block some accesses from you.
  (p.eql/process env
    [{:hacker-news.page/news
      [:hacker-news.item/age
       :hacker-news.item/author-name
       :hacker-news.item/id
       :hacker-news.item/comments-count
       :hacker-news.item/score
       :hacker-news.item/rank-in-page
       :hacker-news.item/source
       :hacker-news.item/title
       :hacker-news.item/url

       :hacker-news.user/id
       :hacker-news.user/karma
       :hacker-news.user/join-date

       {:hacker-news.item/comments
        [:hacker-news.comment/author-name
         :hacker-news.comment/age
         :hacker-news.comment/content
         :hacker-news.comment/id

         :hacker-news.user/id
         :hacker-news.user/karma
         :hacker-news.user/join-date

         {:hacker-news.comment/responses &#x27;...}]}]}]))
</code></pre><h2 id="playing-with-smart-maps">Playing with Smart Maps</h2><p>Let&#x27;s do a pause on implementing HN things and play a bit with what we have.</p><p>In the previous examples we requested information using the <a href="/docs/eql">EQL interface</a>. The
EQL is the most efficient and precise way to use Pathom because in this way, Pathom
can look at a full-size request and optimize as much as possible.</p><p>I&#x27;ll now introduce <a href="/docs/smart-maps">Smart Maps</a> for our play here, which is a different interface to use
Pathom 3. Smart Maps are a data structure that works like Clojure maps, but when you
access some key that the map doesn&#x27;t know the value, it uses the Pathom resolvers to
figure out (when possible).</p><p>To this demo I&#x27;ll start with some item id and fetch some data:</p><pre><code class="language-clojure">(-&gt; (psm/smart-map env {:hacker-news.item/id &quot;25733200&quot;})
    :hacker-news.item/title)
=&gt; &quot;OpenSocial Specification&quot;
</code></pre><p>Cool right?! You may be asking now: how do you know what is accessible?</p><p>To answer that you can leverage the <code>datafy</code> protocol implemented by Pathom Smart Maps:</p><pre><code class="language-clojure">(-&gt; (psm/smart-map env {:hacker-news.item/id &quot;25733200&quot;})
    clojure.datafy/datafy)
=&gt;
{:hacker-news.item/age :com.wsscode.pathom3.connect.operation/unknown-value
 :hacker-news.item/author-name :com.wsscode.pathom3.connect.operation/unknown-value
 :hacker-news.item/comments :com.wsscode.pathom3.connect.operation/unknown-value
 :hacker-news.item/comments-count :com.wsscode.pathom3.connect.operation/unknown-value
 :hacker-news.item/comments-flat :com.wsscode.pathom3.connect.operation/unknown-value
 :hacker-news.item/id &quot;25733200&quot;
 :hacker-news.item/score :com.wsscode.pathom3.connect.operation/unknown-value
 :hacker-news.item/source :com.wsscode.pathom3.connect.operation/unknown-value
 :hacker-news.item/title :com.wsscode.pathom3.connect.operation/unknown-value
 :hacker-news.item/url :com.wsscode.pathom3.connect.operation/unknown-value
 :hacker-news.page/item-hickory :com.wsscode.pathom3.connect.operation/unknown-value
 :hacker-news.page/news :com.wsscode.pathom3.connect.operation/unknown-value
 :hacker-news.page/news-all-pages :com.wsscode.pathom3.connect.operation/unknown-value
 :hacker-news.page/news-hickory :com.wsscode.pathom3.connect.operation/unknown-value
 :hacker-news.page/news-next-page :com.wsscode.pathom3.connect.operation/unknown-value
 :hacker-news.page/news-raw-html :com.wsscode.pathom3.connect.operation/unknown-value
 :hacker-news.page/user-hickory :com.wsscode.pathom3.connect.operation/unknown-value
 :hacker-news.user/id :com.wsscode.pathom3.connect.operation/unknown-value
 :hacker-news.user/join-date :com.wsscode.pathom3.connect.operation/unknown-value
 :hacker-news.user/karma :com.wsscode.pathom3.connect.operation/unknown-value}
</code></pre><p>There we can see many attributes related to the item (given we provided an item id). Also,
you can see all the pages, and some user data (because of the relationship from item to
the user).</p><admonition type="important"><p>The options offered by the Smart Map datafy are contextual. This means if you change
the data you may get different possible paths.</p></admonition><p>To some REPL play with it, here are some suggestions:</p><pre><code class="language-clojure">; author karma from item 25733200
(-&gt; (psm/smart-map env {:hacker-news.item/id &quot;25733200&quot;})
    :hacker-news.user/karma)

; author and content of first comment of the first post on news
(-&gt; (psm/smart-map env {})
    :hacker-news.page/news
    first
    :hacker-news.item/comments
    first
    (select-keys [:hacker-news.comment/author-name
                  :hacker-news.comment/content
                  :hacker-news.user/join-date]))
</code></pre><admonition type="tip"><p>Value responses to smart maps are also smart maps. This is what allows the navigation
like you have seen before. This also means you can datafy at any point to see what paths
are available, for example:</p><pre><code class="language-clojure">(-&gt; (psm/smart-map env {})
    :hacker-news.page/news
    first
    clojure.datafy/datafy)
</code></pre></admonition><h2 id="other-pages">Other pages</h2><p>So far, we extracted some details and the news page. Other pages like <code>past</code> and <code>ask</code>
are quite similar.</p><p>This is the list of resolvers we have to deal with on the news page:</p><pre><code class="language-clojure">news-page-html-string
news-page-hickory
news-page
news-next-page
all-news-pages
</code></pre><p>For the <code>past</code> page, I&#x27;ll simplify that, make the same resolver request the HTML and
parse it, as we did for comments and user details.</p><pre><code class="language-clojure">(defn extract-items-from-list [hickory]
  (let [tbody (-&gt;&gt; hickory
                   (hs/select (hs/class &quot;itemlist&quot;))
                   first
                   (hs/select (hs/tag &quot;tbody&quot;))
                   first)
        tbody (update tbody :content
                #(into []
                       (drop-while
                         (fn [e]
                           (let [cls (some-&gt; e :attrs :class)]
                             (not= cls &quot;athing&quot;))))
                       %))]

    (-&gt;&gt; tbody
         (hs/select (hs/and
                      (hs/tag &quot;tr&quot;)
                      (hs/not (hs/or
                                (hs/class &quot;spacer&quot;)
                                (hs/class &quot;morespace&quot;)))))
         (partition 2)
         (mapv #(hash-map :type :element :tag :tbody :content (vec %)))
         (mapv extract-item-from-hickory))))

(defn extract-more-link [hickory]
  (some-&gt;&gt; hickory
    (hs/select (hs/class &quot;morelink&quot;))
    first :attrs :href))

(pco/defresolver past-page-hickory [{:hacker-news.page/keys [past-page-url]}]
  {::pco/cache-store ::durable-cache*
   ::pco/input       [(pco/? :hacker-news.page/past-page-url)]}
  {:hacker-news.page/past-hickory
   (-&gt; (or past-page-url &quot;https://news.ycombinator.com/front&quot;)
       slurp
       (hc/parse)
       (hc/as-hickory))})

(pco/defresolver past-page [{:hacker-news.page/keys [past-hickory]}]
  {::pco/output
   [{:hacker-news.page/past
     [:hacker-news.item/age
      :hacker-news.item/author-name
      :hacker-news.item/id
      :hacker-news.item/comments-count
      :hacker-news.item/score
      :hacker-news.item/rank-in-page
      :hacker-news.item/source
      :hacker-news.item/title
      :hacker-news.item/url]}]}
  {:hacker-news.page/past
   (extract-items-from-list past-hickory)})

(pco/defresolver past-next-page [{:hacker-news.page/keys [past-hickory]}]
  {::pco/output
   [{:hacker-news.page/past-next-page
     [:hacker-news.page/past-page-url]}]}

  (if-let [link (extract-more-link past-hickory)]
    {:hacker-news.page/past-next-page
     {:hacker-news.page/past-page-url
      (str &quot;https://news.ycombinator.com/&quot; link)}}))
</code></pre><p>If we compare with the news resolvers, they are almost the same. The differences are:</p><ul><li>The resolver names are different</li><li>The attribute names they are used for the collection node are different</li><li>The initial page uses a different URL</li><li>The table with items has some stuff before the actual first item. Our new implementation skips those.</li></ul><p>This similarity can make you feel like there is some higher-order thing to do here.
Especially when we consider that the <code>ask</code> page will be another instance of the same
situation.</p><p>We can generalize this by writing a function that returns some resolvers, let&#x27;s replace
our <code>past</code> page implementation with this idea:</p><pre><code class="language-clojure">(defn hn-page-resolvers [page-name base-url]
  (let [hickory-sym   (symbol &quot;hacker-news.resolvers.page&quot; (str page-name &quot;-hickory&quot;))
        page-sym      (symbol &quot;hacker-news.resolvers.page&quot; page-name)
        next-page-sym (symbol &quot;hacker-news.resolvers.page&quot; (str page-name &quot;-next-page&quot;))

        hickory-kw    (keyword &quot;hacker-news.page&quot; (str page-name &quot;-hickory&quot;))
        page-kw       (keyword &quot;hacker-news.page&quot; page-name)
        next-page-kw  (keyword &quot;hacker-news.page&quot; (str page-name &quot;-next-page&quot;))
        page-url-kw   (keyword &quot;hacker-news.page&quot; (str page-name &quot;-page-url&quot;))]
    [(pco/resolver hickory-sym
       {::pco/cache-store ::durable-cache*
        ::pco/input       [(pco/? page-url-kw)]
        ::pco/output      [hickory-kw]}
       (fn [_ input]
         {hickory-kw
          (-&gt; (or (get input page-url-kw) base-url)
              slurp
              (hc/parse)
              (hc/as-hickory))}))

     (pco/resolver page-sym
       {::pco/input
        [hickory-kw]

        ::pco/output
        [{page-kw
          [:hacker-news.item/age
           :hacker-news.item/author-name
           :hacker-news.item/id
           :hacker-news.item/comments-count
           :hacker-news.item/score
           :hacker-news.item/rank-in-page
           :hacker-news.item/source
           :hacker-news.item/title
           :hacker-news.item/url]}]}
       (fn [_ input]
         {page-kw
          (extract-items-from-list (get input hickory-kw))}))

     (pco/resolver next-page-sym
       {::pco/input
        [hickory-kw]

        ::pco/output
        [{next-page-kw
          [page-url-kw]}]}
       (fn [_ input]

         (if-let [link (extract-more-link (get input hickory-kw))]
           {next-page-kw
            {page-url-kw
             (str &quot;https://news.ycombinator.com/&quot; link)}})))]))
</code></pre><p>Now we have a function that returns 3 resolvers in a vector. We can now use this to
define some pages:</p><pre><code class="language-clojure" metastring="{12-16}">(def env
  (-&gt; {::durable-cache* cache*}
      (pci/register
        [(pbir/alias-resolver :hacker-news.item/author-name :hacker-news.user/id)
         (pbir/alias-resolver :hacker-news.comment/author-name :hacker-news.user/id)
         news-page-html-string
         news-page-hickory
         news-page
         news-next-page
         all-news-pages

         ; this is different than news, news is the home, newest are the most recent
         (hn-page-resolvers &quot;newest&quot; &quot;https://news.ycombinator.com/newest&quot;)
         (hn-page-resolvers &quot;past&quot; &quot;https://news.ycombinator.com/front&quot;)
         (hn-page-resolvers &quot;ask&quot; &quot;https://news.ycombinator.com/ask&quot;)
         (hn-page-resolvers &quot;show&quot; &quot;https://news.ycombinator.com/show&quot;)

         user-data-hickory
         user-data

         item-page-hickory
         item-data
         item-comments-flat
         item-comments])))
</code></pre><admonition type="note"><p><code>pci/register</code> accepts nested vectors as definitions. It flattens the structure out
in the process of registration.</p></admonition><p>Just like that, we have four new pages implemented!</p><h2 id="review">Review</h2><p>That&#x27;s it for this tutorial, a recap of what we saw here:</p><ul><li>Design attribute names for Hacker News data</li><li>Use Hickory to parse HTML data</li><li>Create resolvers to connect the system</li><li>Use recursive queries to traverse pagination</li><li>Use optional inputs</li><li>Use nested queries with recursive inputs</li><li>Smart Maps exploration</li><li>Creates resolvers dynamically using functions</li></ul><p>I hope you learned some new things about Pathom 3 in the process.</p><p>You can find the complete source code for this demo at: <a href="https://github.com/wilkerlucio/pathom3-docs/blob/master/src/main/com/wsscode/pathom3/docs/demos/tutorials/hacker_news_scrapper.clj">https://github.com/wilkerlucio/pathom3-docs/blob/master/src/main/com/wsscode/pathom3/docs/demos/tutorials/hacker_news_scrapper.clj</a></p><h2 id="exercises">Exercises</h2><p>If you like to keep playing, here are some suggestions to add:</p><ul><li>Parse comments back, linking back to the items they point to</li><li>Make relationships from the user to its submissions, comments, and favorites</li><li>Support logging in user and they use mutations to implement voting or submission of new entries</li><li>Replace the HTML parsing implementation with the <a href="https://github.com/HackerNews/API">Hacker News API</a></li></ul></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/wilkerlucio/pathom3-docs/edit/master/docs/tutorials/hacker-news-scraper.mdx" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/integrations/graphql"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">GraphQL</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/tutorials/serverless-pathom-gcf"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Serverless Pathom with GCF</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#attribute-mapping" class="table-of-contents__link toc-highlight">Attribute mapping</a></li><li><a href="#reading-the-news-page" class="table-of-contents__link toc-highlight">Reading the news page</a><ul><li><a href="#finding-the-items" class="table-of-contents__link toc-highlight">Finding the items</a></li><li><a href="#read-item-details" class="table-of-contents__link toc-highlight">Read item details</a></li></ul></li><li><a href="#make-a-resolver" class="table-of-contents__link toc-highlight">Make a resolver</a><ul><li><a href="#caching-the-request-for-development" class="table-of-contents__link toc-highlight">Caching the request for development</a></li></ul></li><li><a href="#traversing-pagination" class="table-of-contents__link toc-highlight">Traversing pagination</a></li><li><a href="#read-user-data" class="table-of-contents__link toc-highlight">Read user data</a></li><li><a href="#read-comments" class="table-of-contents__link toc-highlight">Read comments</a></li><li><a href="#playing-with-smart-maps" class="table-of-contents__link toc-highlight">Playing with Smart Maps</a></li><li><a href="#other-pages" class="table-of-contents__link toc-highlight">Other pages</a></li><li><a href="#review" class="table-of-contents__link toc-highlight">Review</a></li><li><a href="#exercises" class="table-of-contents__link toc-highlight">Exercises</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Presentations</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://www.youtube.com/watch?v=YaHiff2vZ_o" target="_blank" rel="noopener noreferrer" class="footer__link-item">Data Navigation with Pathom 3<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://www.youtube.com/watch?v=IS3i3DTUnAI" target="_blank" rel="noopener noreferrer" class="footer__link-item">Conj 2019 - The Maximal Graph<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://www.youtube.com/watch?v=yyVKf2U8YVg" target="_blank" rel="noopener noreferrer" class="footer__link-item">Conj 2018 - Scaling Full Stack Applications<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://www.youtube.com/watch?v=r3zywlNflJI" target="_blank" rel="noopener noreferrer" class="footer__link-item">Dutch Clojure Days 2018 - Clojure Graph API’s<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://clojurians.slack.com/messages/pathom/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Slack<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 Wilker Lucio</div></div></div></footer></div>
<script src="/assets/js/runtime~main.7be6ae2a.js"></script>
<script src="/assets/js/main.670c6fc5.js"></script>
</body>
</html>