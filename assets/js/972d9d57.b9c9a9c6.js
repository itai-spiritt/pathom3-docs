"use strict";(self.webpackChunkpathom_3_docs=self.webpackChunkpathom_3_docs||[]).push([[937],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),m=c(n),d=r,h=m["".concat(l,".").concat(d)]||m[d]||u[d]||o;return n?a.createElement(h,i(i({ref:t},p),{},{components:n})):a.createElement(h,i({ref:t},p))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[m]="string"==typeof e?e:r,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},9880:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var a=n(7462),r=(n(7294),n(3905));const o={id:"introduction",title:"Getting Started",slug:"/"},i=void 0,s={unversionedId:"introduction",id:"introduction",title:"Getting Started",description:"Pathom is a Clojure/script library to model attribute relationships.",source:"@site/docs/introduction.mdx",sourceDirName:".",slug:"/",permalink:"/docs/",draft:!1,editUrl:"https://github.com/wilkerlucio/pathom3-docs/edit/master/docs/introduction.mdx",tags:[],version:"current",frontMatter:{id:"introduction",title:"Getting Started",slug:"/"},sidebar:"docs",next:{title:"Pathom Tutorial",permalink:"/docs/tutorial"}},l={},c=[{value:"Install",id:"install",level:2},{value:"Namespace aliases",id:"namespace-aliases",level:2},{value:"General attribute modeling view",id:"general-attribute-modeling-view",level:2},{value:"Core Concepts",id:"core-concepts",level:2},{value:"Resolver",id:"resolver",level:3},{value:"Environment",id:"environment",level:3},{value:"Planner",id:"planner",level:3},{value:"Runner",id:"runner",level:3},{value:"Interface",id:"interface",level:3}],p={toc:c},m="wrapper";function u(e){let{components:t,...n}=e;return(0,r.kt)(m,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Pathom")," is a Clojure/script library to model attribute relationships."),(0,r.kt)("h2",{id:"install"},"Install"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clojure"},'{:deps\n {com.wsscode/pathom3 {:mvn/version "LATEST_VERSION"}}}\n')),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"Latest version: ",(0,r.kt)("a",{parentName:"p",href:"https://clojars.org/com.wsscode/pathom3"},(0,r.kt)("img",{parentName:"a",src:"https://img.shields.io/clojars/v/com.wsscode/pathom3.svg",alt:"Clojars Project"})))),(0,r.kt)("h2",{id:"namespace-aliases"},"Namespace aliases"),(0,r.kt)("p",null,"When you read code from the examples in this documentation they will use alias to reference\nnamespaces, here you can find what the aliases point to:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clojure"},"; main namespaces, you are very likely to use at least these\n[com.wsscode.pathom3.connect.indexes :as pci]\n[com.wsscode.pathom3.connect.operation :as pco]\n[com.wsscode.pathom3.interface.eql :as p.eql]\n\n; now some common namespaces to use\n[com.wsscode.pathom3.connect.built-in.resolvers :as pbir]\n[com.wsscode.pathom3.connect.built-in.plugins :as pbip]\n[com.wsscode.pathom3.interface.async.eql :as p.a.eql]\n[com.wsscode.pathom3.interface.smart-map :as psm]\n[com.wsscode.pathom3.plugin :as p.plugin]\n\n; now the least common used\n[com.wsscode.pathom3.cache :as p.cache]\n[com.wsscode.pathom3.connect.foreign :as pcf]\n[com.wsscode.pathom3.connect.operation.transit :as pcot]\n[com.wsscode.pathom3.connect.planner :as pcp]\n[com.wsscode.pathom3.connect.runner :as pcr]\n[com.wsscode.pathom3.error :as p.error]\n[com.wsscode.pathom3.format.eql :as pf.eql]\n[com.wsscode.pathom3.path :as p.path]\n")),(0,r.kt)("h2",{id:"general-attribute-modeling-view"},"General attribute modeling view"),(0,r.kt)("p",null,"Attribute modeling is a way to think and design information systems."),(0,r.kt)("p",null,"Consider the question: What's the temperature in the city of Recife now?"),(0,r.kt)("p",null,"Using my attribute modeler hat, I can break this description into two attributes and one\nvalue. The demand is for a ",(0,r.kt)("inlineCode",{parentName:"p"},":temperature"),", and the available information is the\n",(0,r.kt)("inlineCode",{parentName:"p"},":city")," with the value of ",(0,r.kt)("inlineCode",{parentName:"p"},"Recife"),". Or we can express it as a Clojure map:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clojure"},'{:city        "Recife"\n :temperature ?}\n')),(0,r.kt)("p",null,"Note we left ",(0,r.kt)("inlineCode",{parentName:"p"},"?")," for the unknown attributes. In a way, this map expresses the same thing\nas the question we had before."),(0,r.kt)("p",null,"Now, to realize the ",(0,r.kt)("inlineCode",{parentName:"p"},":temperature")," from the ",(0,r.kt)("inlineCode",{parentName:"p"},"city"),", we write a resolver\nestablishing this relationship."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clojure"},'; our mock temperatures database\n(def temperatures\n  {"Recife" 23})\n\n(pco/defresolver temperature-from-city [{:keys [city]}]\n  {:temperature (get temperatures city)})\n')),(0,r.kt)("p",null,"A resolver looks like a function but with some constraints:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"The resolver input ",(0,r.kt)("strong",{parentName:"li"},"must")," be a map, so the input information is labeled."),(0,r.kt)("li",{parentName:"ol"},"A resolver ",(0,r.kt)("strong",{parentName:"li"},"must")," return a map, so the output information is labeled."),(0,r.kt)("li",{parentName:"ol"},"A resolver may also receive another map, containing the environment information.")),(0,r.kt)("p",null,"The next step is to create the indexes:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clojure"},"(def indexes\n  (pci/register [temperature-from-city]))\n")),(0,r.kt)("p",null,"Pathom uses the indexes to traverse the attribute relationships."),(0,r.kt)("p",null,"Now to make the original question to Pathom, we are going to use the ",(0,r.kt)("a",{parentName:"p",href:"/docs/smart-maps"},"Smart Map")," interface:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clojure"},'; this creates a smart map, using our indexes, and with some initial data\n(def smart-map (psm/smart-map indexes {:city "Recife"}))\n\n; smart maps work as regular maps when looking for the initial data\n(:city smart-map); => "Recife"\n\n; but the difference comes when we ask for keys not present in the map, but reachable\n; via resolvers\n(:temperature smart-map); => 23\n')),(0,r.kt)("admonition",{type:"important"},(0,r.kt)("p",{parentName:"admonition"},"Note that in this example, we only mention the indexes and the attributes, the resolver\nnames get abstracted from the user and left for Pathom to figure when to call then.")),(0,r.kt)("p",null,"Now consider a slightly different question: Is it cold in ",(0,r.kt)("inlineCode",{parentName:"p"},"Recife")," now?"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clojure"},'{:city  "Recife"\n :cold? ?}\n')),(0,r.kt)("p",null,"To compute the ",(0,r.kt)("inlineCode",{parentName:"p"},":cold?")," attribute, we can write a resolver that depends on the ",(0,r.kt)("inlineCode",{parentName:"p"},":temperature"),"\nattribute:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clojure"},"(pco/defresolver cold? [{:keys [temperature]}]\n  {:cold? (< temperature 20)})\n")),(0,r.kt)("p",null,"Update the indexes definition to also include the ",(0,r.kt)("inlineCode",{parentName:"p"},"cold?")," resolver:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clojure"},"(def indexes\n  (pci/register [temperature-from-city cold?]))\n")),(0,r.kt)("p",null,"Now, back to the question: Is it cold in ",(0,r.kt)("inlineCode",{parentName:"p"},"Recife")," now? This time we will use a different\ninterface, the ",(0,r.kt)("a",{parentName:"p",href:"/docs/eql"},"EQL")," interface."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clojure"},'; this time we will use the EQL interface to trigger the Pathom engine\n(p.eql/process\n  indexes\n  {:city "Recife"}\n  [:cold?])\n; => {:cold? false}\n')),(0,r.kt)("p",null,'Note that our "lookup code" remains the same size, although we have to run more operations\nnow. This ability to abstract the function call chain is the primary utility you should\nlook for in Pathom.'),(0,r.kt)("p",null,"In this getting started, we talked a bit about attribute modeling, how to write a few\nresolvers and how to trigger the Pathom engine to fulfill attribute questions."),(0,r.kt)("p",null,"You can find a complete tutorial playing with weather API's at the ",(0,r.kt)("a",{parentName:"p",href:"/docs/tutorial"},"Pathom Tutorial"),"\npage."),(0,r.kt)("h2",{id:"core-concepts"},"Core Concepts"),(0,r.kt)("p",null,"Here is a list of the main concepts in Pathom that can help you navigate the\ndocumentation."),(0,r.kt)("h3",{id:"resolver"},"Resolver"),(0,r.kt)("p",null,"Resolvers are building blocks that establish relationships between attributes. Pathom\nsecret sauce is the ability to traverse a graph of attribute relationships, defined by\nresolvers, given some user request."),(0,r.kt)("h3",{id:"environment"},"Environment"),(0,r.kt)("p",null,"Is a map containing all the necessary context required to process a request. Data for\nPathom internals uses Pathom-specific namespaced keys, and you will typically add your\nown entries (database connections, etc.) such that all these data are available to your\nresolvers."),(0,r.kt)("h3",{id:"planner"},"Planner"),(0,r.kt)("p",null,"Given the environment, some initial data and a request, the planner is responsible for\nfiguring what resolvers to call, in what order."),(0,r.kt)("h3",{id:"runner"},"Runner"),(0,r.kt)("p",null,"Once the plan is ready the runner executes the plan, by traversing and executing resolvers,\nthen responses are coming as expected and chooses the path when multiple options\nshaping the results to satisfy the request. It handles errors as well as potential conflicts\nare available.(e.g. multiple resolvers can handle a given request)."),(0,r.kt)("h3",{id:"interface"},"Interface"),(0,r.kt)("p",null,"To bundle the process together, you interact using one of the Pathom interfaces:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/eql"},"EQL")," is a syntax that allows users to express a data shape, and then Pathom\nfill the requirements using the logic from resolvers."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/smart-maps"},"Smart Maps")," is a custom map data structure, similar to a ",(0,r.kt)("a",{parentName:"li",href:"https://docs.datomic.com/on-prem/entities.html"},"Datomic Entity"),", but instead\nof loading from a database, realized using resolvers.")))}u.isMDXComponent=!0}}]);