"use strict";(self.webpackChunkpathom_3_docs=self.webpackChunkpathom_3_docs||[]).push([[91],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>h});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)t=s[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)t=s[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var c=a.createContext({}),i=function(e){var n=a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},p=function(e){var n=i(e.components);return a.createElement(c.Provider,{value:n},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,s=e.originalType,c=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),m=i(t),d=r,h=m["".concat(c,".").concat(d)]||m[d]||u[d]||s;return t?a.createElement(h,o(o({ref:n},p),{},{components:t})):a.createElement(h,o({ref:n},p))}));function h(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var s=t.length,o=new Array(s);o[0]=d;var l={};for(var c in n)hasOwnProperty.call(n,c)&&(l[c]=n[c]);l.originalType=e,l[m]="string"==typeof e?e:r,o[1]=l;for(var i=2;i<s;i++)o[i]=t[i];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},5741:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>l,toc:()=>i});var a=t(7462),r=(t(7294),t(3905));const s={title:"Async"},o=void 0,l={unversionedId:"async",id:"async",title:"Async",description:"Async process allows Pathom to process resolvers that require async processing.",source:"@site/docs/async.mdx",sourceDirName:".",slug:"/async",permalink:"/docs/async",draft:!1,editUrl:"https://github.com/wilkerlucio/pathom3-docs/edit/master/docs/async.mdx",tags:[],version:"current",frontMatter:{title:"Async"},sidebar:"docs",previous:{title:"Built-in Plugins",permalink:"/docs/built-in-plugins"},next:{title:"Debugging",permalink:"/docs/debugging"}},c={},i=[{value:"Promesa",id:"promesa",level:2},{value:"Async resolvers",id:"async-resolvers",level:2},{value:"Async EQL",id:"async-eql",level:2},{value:"Async ENV",id:"async-env",level:2},{value:"Parallel Process",id:"parallel-process",level:2},{value:"Batching in parallel mode",id:"batching-in-parallel-mode",level:3},{value:"Using core.async",id:"using-coreasync",level:2}],p={toc:i},m="wrapper";function u(e){let{components:n,...s}=e;return(0,r.kt)(m,(0,a.Z)({},p,s,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Async process allows Pathom to process resolvers that require async processing."),(0,r.kt)("p",null,"JS environments are limited without async support, you can't trigger HTTP or database\nrequests."),(0,r.kt)("p",null,"In this section, you will learn how to use the async features from Pathom 3."),(0,r.kt)("h2",{id:"promesa"},"Promesa"),(0,r.kt)("p",null,"Pathom 3 uses the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/funcool/promesa"},"Promesa")," library under the hood to manage the async process."),(0,r.kt)("p",null,"Promesa uses native ",(0,r.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise"},"Promises"),"\nin Javascript environments, and ",(0,r.kt)("a",{parentName:"p",href:"https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/CompletableFuture.html"},"CompletableFuture"),"\non the JVM."),(0,r.kt)("p",null,"I'll use the term ",(0,r.kt)("inlineCode",{parentName:"p"},"future")," to refer to both ",(0,r.kt)("inlineCode",{parentName:"p"},"Promises")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"CompletableFuture")," in the\nrest of this page."),(0,r.kt)("h2",{id:"async-resolvers"},"Async resolvers"),(0,r.kt)("p",null,"Async resolvers are not unique. They use the same constructs as the other resolvers\nyou know so far."),(0,r.kt)("p",null,"The difference when you write an async resolver is that it may return a ",(0,r.kt)("inlineCode",{parentName:"p"},"future")," from\nthe resolver, for example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clojure"},'(ns com.wsscode.pathom3.docs.demos.core.async\n  (:require [com.wsscode.pathom3.connect.indexes :as pci]\n            [com.wsscode.pathom3.connect.operation :as pco]\n            [promesa.core :as p]))\n\n(defn json-get [url]\n  (p/let [resp (js/fetch url)\n          json (.json resp)]\n    (js->clj json :keywordize-keys true)))\n\n(pco/defresolver age-from-name [{::keys [first-name]}]\n  {::pco/output [::age]}\n  (p/let [{:keys [age]} (json-get (str "https://api.agify.io/?name=" first-name))]\n    {::age age}))\n')),(0,r.kt)("admonition",{type:"important"},(0,r.kt)("p",{parentName:"admonition"},"The ",(0,r.kt)("inlineCode",{parentName:"p"},"future")," must be around the return map in the resolver. Returning futures as\nvalues for the keys won't work. This is a bad example:"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-clojure"},'(pco/defresolver age-from-name [{::keys [first-name]}]\n  {::pco/output [::age]}\n  ; return map\n  {::age\n   ; with key value as a promise, won\'t work\n   (p/let [{:keys [age]} (json-get (str "https://api.agify.io/?name=" first-name))]\n     age)})\n'))),(0,r.kt)("h2",{id:"async-eql"},"Async EQL"),(0,r.kt)("p",null,"To async, there is only the EQL interface. It behaves similar to the ",(0,r.kt)("a",{parentName:"p",href:"/docs/eql"},"EQL"),"\nstandard interface, but returns a promise in the end."),(0,r.kt)("p",null,"Example usage:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clojure",metastring:"{4,17-19,22-25}","{4,17-19,22-25}":!0},'(ns com.wsscode.pathom3.docs.demos.core.async\n  (:require [com.wsscode.pathom3.connect.indexes :as pci]\n            [com.wsscode.pathom3.connect.operation :as pco]\n            [com.wsscode.pathom3.interface.async.eql :as p.a.eql]\n            [promesa.core :as p]))\n\n(defn json-get [url]\n  (p/let [resp (js/fetch url)\n          json (.json resp)]\n    (js->clj json :keywordize-keys true)))\n\n(pco/defresolver age-from-name [{::keys [first-name]}]\n  {::pco/output [::age]}\n  (p/let [{:keys [age]} (json-get (str "https://api.agify.io/?name=" first-name))]\n    {::age age}))\n\n(def env\n  (pci/register\n    age-from-name))\n\n(comment\n  (p/let [res (p.a.eql/process env\n                {::first-name "Ada"}\n                [::age])]\n    (cljs.pprint/pprint res)))\n')),(0,r.kt)("h2",{id:"async-env"},"Async ENV"),(0,r.kt)("p",null,"When using the async helpers, Pathom also supports the ",(0,r.kt)("inlineCode",{parentName:"p"},"env")," being async."),(0,r.kt)("p",null,"This is useful when the environment build requires async operations. For example, in\na CLJS client, to integrate a remote Pathom service we need to request the index\nasync:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clojure"},'(defn transit-request [url body]\n  (p/let [resp (js/fetch url\n                 #js {:method "POST"\n                      :body   (tt/write-str body {:handlers pcot/write-handlers})})\n          text (.text resp)]\n    (tt/read-str text {:handlers pcot/read-handlers})))\n\n(defn pathom-remote [request]\n  (transit-request "https://name-server.com" request))\n\n(def users\n  {1 {:person/first-name "Alex"\n      :person/last-name  "French Guy Cooking"}\n   2 {:person/first-name "Denise"\n      :person/last-name  "Mascarenhas"}})\n\n; note now we make env a promise instead of a map\n(def async-env\n  (p/let [rem (pcf/foreign-register pathom-remote)]\n    (pci/register\n      [rem\n       (pbir/static-table-resolver :person/id users)])))\n\n;           use directly as env, supported by Pathom\n(p/let [res (p.a.eql/process async-env\n              {:person/id 2}\n              [:person/full-name])]\n  (js/console.log "!! " res))\n')),(0,r.kt)("h2",{id:"parallel-process"},"Parallel Process"),(0,r.kt)("p",null,"In Parallel mode Pathom will run as many things at the same time as it can."),(0,r.kt)("p",null,"Example setup:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clojure"},'(pco/defresolver random-dog-image []\n  {::pco/output [::random-dog-image-url]\n   ::pco/cache? false}\n  (p/let [{:keys [message]} (json-get "https://dog.ceo/api/breeds/image/random")]\n    {::random-dog-image-url message}))\n\n(pco/defresolver random-cat-image []\n  {::pco/output [::random-cat-image-url]\n   ::pco/cache? false}\n  (p/let [{:keys [file]} (json-get "https://aws.random.cat/meow")]\n    {::random-cat-image-url file}))\n\n(pco/defresolver random-pets [{::keys [random-dog-image-url\n                                       random-cat-image-url]}]\n  {::random-pets [random-dog-image-url\n                  random-cat-image-url]})\n\n(def parallel-env\n  (-> {::p.a.eql/parallel? true}\n      (pci/register\n        [random-dog-image\n         random-cat-image\n         random-pets])))\n\n(p.a.eql/process async-env\n  {:items [{} {} {} {} {}]}\n  [{:items\n    [::random-pets]}])\n')),(0,r.kt)("p",null,"In the previous example, we have 5 items and load a random dog and cat picture\nfor each. Using Pathom Viz we can see the items running in parallel:"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Pets Parallel",src:t(8650).Z,width:"4096",height:"1470"})),(0,r.kt)("p",null,"Let's compare it with the serial runner:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clojure"},"(def parallel-env\n  (-> {::p.a.eql/parallel? false} ; disable parallel\n      (pci/register\n        [random-dog-image\n         random-cat-image\n         random-pets])))\n")),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Pets Serial",src:t(4330).Z,width:"4096",height:"1470"})),(0,r.kt)("p",null,"Now you can see the cascading and each event running one after the other."),(0,r.kt)("h3",{id:"batching-in-parallel-mode"},"Batching in parallel mode"),(0,r.kt)("p",null,"In Parallel mode the batch process is different from the serial modes."),(0,r.kt)("p",null,"In serial mode, the batches run after scanning every entity on the query, to trigger\nthe items and resume each graph run."),(0,r.kt)("p",null,'In parallel, the notion of "scanning" isn\'t as clear and requires a different approach.'),(0,r.kt)("p",null,"Instead of waiting for the end scan, Pathom will run batches based on time, it waits\nfor a window without any new entries and run."),(0,r.kt)("p",null,"The default wait time is 10ms, and you can change it setting via the\n",(0,r.kt)("inlineCode",{parentName:"p"},":com.wsscode.pathom3.connect.runner.parallel/batch-hold-delay-ms")," variable in your\nenvironment."),(0,r.kt)("p",null,"You can also force a flush at a certain number of items collected for batching using\nthe ",(0,r.kt)("inlineCode",{parentName:"p"},":com.wsscode.pathom3.connect.runner.parallel/batch-hold-flush-threshold"),", the\ndefault value is ",(0,r.kt)("inlineCode",{parentName:"p"},"nil"),", which will make it flush only by time."),(0,r.kt)("h2",{id:"using-coreasync"},"Using core.async"),(0,r.kt)("p",null,"To use core.async, we can extend the channel protocol to implement the conversion from\na core.async channel to a future."),(0,r.kt)("p",null,"I have made a ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/wilkerlucio/promesa-bridges"},"library")," to share the implementation of this extension, this way we can\navoid issues when multiple people try to extend the same type."),(0,r.kt)("p",null,"First add promesa-bridges to your dependencies:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clojure"},'{:deps {com.wsscode/promesa-bridges {:mvn/version "2021.01.20"}}}\n')),(0,r.kt)("p",null,"Then include and use it:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clojure"},'(ns com.wsscode.pathom3.docs.demos.core.async-extend-core-async\n  (:require\n    [clojure.core.async :as async :refer [go <!]]\n    [com.wsscode.promesa.bridges.core-async]\n    [com.wsscode.pathom3.connect.indexes :as pci]\n    [com.wsscode.pathom3.connect.operation :as pco]\n    [com.wsscode.pathom3.interface.async.eql :as p.a.eql]\n    [promesa.core :as p]))\n\n(pco/defresolver slow-resolver []\n  {::pco/output [::slow-response]}\n  ; returning a channel from resolver\n  (go\n    (<! (async/timeout 400))\n    {::slow-response "done"}))\n\n(def env (pci/register slow-resolver))\n\n(comment\n  (p/let [res (p.a.eql/process env [::slow-response])]\n    (cljs.pprint/pprint res)))\n')),(0,r.kt)("p",null,"If you like to add more extensions to ",(0,r.kt)("inlineCode",{parentName:"p"},"promesa-bridges"),", please send a pull request."))}u.isMDXComponent=!0},8650:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/pets-parallel-1a6895d0ab4068f1848a8056223ffa2a.png"},4330:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/pets-serial-aa58b284bcf1f24ecc4141f3cdde7708.png"}}]);