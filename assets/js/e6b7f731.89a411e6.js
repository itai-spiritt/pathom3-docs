"use strict";(self.webpackChunkpathom_3_docs=self.webpackChunkpathom_3_docs||[]).push([[630],{3905:(e,n,t)=>{t.d(n,{kt:()=>k});var a=t(7294);function s(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){s(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,a,s=function(e,n){if(null==e)return{};var t,a,s={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(s[t]=e[t]);return s}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(s[t]=e[t])}return s}var c=a.createContext({}),l=function(e){var n=a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},h="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},p=a.forwardRef((function(e,n){var t=e.components,s=e.mdxType,r=e.originalType,c=e.parentName,h=i(e,["components","mdxType","originalType","parentName"]),p=l(t),k=s,u=p["".concat(c,".").concat(k)]||p[k]||m[k]||r;return t?a.createElement(u,o(o({ref:n},h),{},{components:t})):a.createElement(u,o({ref:n},h))}));function k(e,n){var t=arguments,s=n&&n.mdxType;if("string"==typeof e||s){var r=t.length,o=new Array(r);o[0]=p;var i={};for(var c in n)hasOwnProperty.call(n,c)&&(i[c]=n[c]);i.originalType=e,i[h]="string"==typeof e?e:s,o[1]=i;for(var l=2;l<r;l++)o[l]=t[l];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}p.displayName="MDXCreateElement"},3995:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>r,metadata:()=>i,toc:()=>l});var a=t(7462),s=(t(7294),t(3905));const r={title:"Hacker News Scraper"},o=void 0,i={unversionedId:"tutorials/hacker-news-scraper",id:"tutorials/hacker-news-scraper",title:"Hacker News Scraper",description:"In this tutorial, we are going to write a scraper to extract information from hacker",source:"@site/docs/tutorials/hacker-news-scraper.mdx",sourceDirName:"tutorials",slug:"/tutorials/hacker-news-scraper",permalink:"/docs/tutorials/hacker-news-scraper",draft:!1,editUrl:"https://github.com/wilkerlucio/pathom3-docs/edit/master/docs/tutorials/hacker-news-scraper.mdx",tags:[],version:"current",frontMatter:{title:"Hacker News Scraper"},sidebar:"docs",previous:{title:"GraphQL",permalink:"/docs/integrations/graphql"},next:{title:"Serverless Pathom with GCF",permalink:"/docs/tutorials/serverless-pathom-gcf"}},c={},l=[{value:"Attribute mapping",id:"attribute-mapping",level:2},{value:"Reading the news page",id:"reading-the-news-page",level:2},{value:"Finding the items",id:"finding-the-items",level:3},{value:"Read item details",id:"read-item-details",level:3},{value:"Make a resolver",id:"make-a-resolver",level:2},{value:"Caching the request for development",id:"caching-the-request-for-development",level:3},{value:"Traversing pagination",id:"traversing-pagination",level:2},{value:"Read user data",id:"read-user-data",level:2},{value:"Read comments",id:"read-comments",level:2},{value:"Playing with Smart Maps",id:"playing-with-smart-maps",level:2},{value:"Other pages",id:"other-pages",level:2},{value:"Review",id:"review",level:2},{value:"Exercises",id:"exercises",level:2}],h={toc:l},m="wrapper";function p(e){let{components:n,...r}=e;return(0,s.kt)(m,(0,a.Z)({},h,r,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"In this tutorial, we are going to write a scraper to extract information from hacker\nnews pages using Pathom."),(0,s.kt)("p",null,"Pathom enables declarative programming for data processing."),(0,s.kt)("p",null,"Using Pathom, we will map out the data from Hacker News in attributes, and then we use\nthis mapping in various ways to query information."),(0,s.kt)("p",null,"This scraper will be capable of:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Listing hacker news pages: news, past, ask"),(0,s.kt)("li",{parentName:"ul"},"Read user data"),(0,s.kt)("li",{parentName:"ul"},"Read comments from items"),(0,s.kt)("li",{parentName:"ul"},"Navigate on pagination")),(0,s.kt)("p",null,"Let's start!"),(0,s.kt)("h2",{id:"attribute-mapping"},"Attribute mapping"),(0,s.kt)("p",null,"The first step is to make names for every attribute we want to handle."),(0,s.kt)("p",null,"Here is a quick guide you can follow to help in this process:"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"Pick a general prefix, usually the product/service name. For this case, I'll pick: ",(0,s.kt)("inlineCode",{parentName:"li"},"hacker-news"),"."),(0,s.kt)("li",{parentName:"ol"},"For data points, add some entity context in the name. In the case of Hacker News, I see they call it ",(0,s.kt)("inlineCode",{parentName:"li"},"item"),"."),(0,s.kt)("li",{parentName:"ol"},"If you mean to read collections, give each collection a name.")),(0,s.kt)("admonition",{type:"note"},(0,s.kt)("p",{parentName:"admonition"},"If you are developing a product for a company, use the company name for step one.\nAvoid having short names like ",(0,s.kt)("inlineCode",{parentName:"p"},":user/name")," since they have a higher collision chance.\nThis makes your names much harder to integrate with other names.")),(0,s.kt)("p",null,"Let's see what are the interesting data points to extract from the Hacker News front\npage:"),(0,s.kt)("div",{className:"pathom-diagram"},(0,s.kt)("p",null,"  ",(0,s.kt)("img",{alt:"Front Page Mapping",src:t(7065).Z,width:"1197",height:"648"}))),(0,s.kt)("p",null,"The circle cursors point to visible points of data. The open diamond means the data\nis hidden (inside the markup)."),(0,s.kt)("p",null,"I used the name ",(0,s.kt)("inlineCode",{parentName:"p"},":hacker-news.page/news")," to name the collection of items for this page."),(0,s.kt)("p",null,"Here is a text version of all the declared attributes:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-clojure"},"; item attributes\n:hacker-news.item/age\n:hacker-news.item/author-name\n:hacker-news.item/id\n:hacker-news.item/comments-count\n:hacker-news.item/score\n:hacker-news.item/rank-in-page\n:hacker-news.item/source\n:hacker-news.item/title\n:hacker-news.item/url\n\n; news collection\n:hacker-news.page/news\n")),(0,s.kt)("h2",{id:"reading-the-news-page"},"Reading the news page"),(0,s.kt)("p",null,"For the implementation, I'll use the ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/davidsantiago/hickory"},"Hickory")," library to parse the HTML and extract\nthe data."),(0,s.kt)("p",null,"To start, we need to explore and figure the code to extract the information fragments\nfrom the HTML page."),(0,s.kt)("p",null,"I like to start reading the raw HTML and saving it on a ",(0,s.kt)("inlineCode",{parentName:"p"},"defonce"),", so I can keep reloading\nthe REPL while has a cached version of sample data:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-clojure"},'(ns com.wsscode.pathom3.docs.demos.tutorials.hacker-news-scrapper)\n\n(defonce sample-html (slurp (str "https://news.ycombinator.com/news")))\n')),(0,s.kt)("p",null,"It's time to learn about the HTML structure of Hacker News page. I like to use the\nChrome inspector to navigate. I can see there is a table with the class ",(0,s.kt)("inlineCode",{parentName:"p"},"itemlist"),"\nwrapping the item elements."),(0,s.kt)("div",{className:"pathom-diagram"},(0,s.kt)("p",null,"  ",(0,s.kt)("img",{alt:"Front Page Mapping",src:t(9281).Z,width:"1133",height:"656"}))),(0,s.kt)("h3",{id:"finding-the-items"},"Finding the items"),(0,s.kt)("p",null,"I'll start this query using our data and Hickory and try it on the REPL, I suggest\nyou follow along in your REPL:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-clojure"},'(ns com.wsscode.pathom3.docs.demos.tutorials.hacker-news-scrapper\n  (:require [hickory.core :as hc]\n            [hickory.select :as hs]))\n\n(defonce sample-html (slurp (str "https://news.ycombinator.com/news")))\n\n(comment\n  ; navigate to table element\n  (->> sample-html\n       (hc/parse)\n       (hc/as-hickory)\n       (hs/select (hs/class "itemlist"))\n       first))\n')),(0,s.kt)("p",null,"Now we can extract the rows out. Hacker News doesn't make it straight forward. When I\nlook at the rows, I see each item uses two table rows. Then it has a spacer row between\nthe next two with the class ",(0,s.kt)("inlineCode",{parentName:"p"},"spacer"),". To add more details, there is a\ndifferent row with the class ",(0,s.kt)("inlineCode",{parentName:"p"},"morespace")," in the end."),(0,s.kt)("p",null,"To deal with this, we are going to query for rows, removing the ones with the class ",(0,s.kt)("inlineCode",{parentName:"p"},"spacer"),"\nor ",(0,s.kt)("inlineCode",{parentName:"p"},"morespace"),"."),(0,s.kt)("p",null,"This is how we can do it with Hickory:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-clojure"},'(comment\n  (->> sample-html\n       (hc/parse)\n       (hc/as-hickory)\n       (hs/select (hs/class "itemlist"))\n       first\n       (hs/select (hs/and\n                    (hs/tag "tr")\n                    (hs/not (hs/or\n                              (hs/class "spacer")\n                              (hs/class "morespace")))))\n       (partition 2)\n       (mapv #(hash-map :type :element :tag :tbody :content (vec %)))))\n')),(0,s.kt)("p",null,"Now we have a collection where each item represents a row in Hacker News."),(0,s.kt)("admonition",{type:"note"},(0,s.kt)("p",{parentName:"admonition"},"After the ",(0,s.kt)("inlineCode",{parentName:"p"},"partition")," the ",(0,s.kt)("inlineCode",{parentName:"p"},"mapv")," is making a fake element for Hickory, this way we\ncan treat the two rows as a single element for querying in.")),(0,s.kt)("h3",{id:"read-item-details"},"Read item details"),(0,s.kt)("p",null,"Now for each item, we need to extract the attributes we want. Here are a few helpers\nwe will use for it:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-clojure"},'(defn find-text\n  "Given an element, traverse the contents until it reaches some text."\n  [el]\n  (loop [item (first (:content el))]\n    (if (string? item)\n      item\n      (if-let [next (some-> item :content first)]\n        (recur next)\n        nil))))\n\n(defn class-text\n  "Get the text for a given element that matches a css class."\n  [el class]\n  (->> (hs/select (hs/class class) el)\n       first\n       (find-text)))\n\n(defn select-number\n  "Extract the first integer from a string."\n  [x]\n  (if-let [[_ n] (re-find #"(\\d+)" (str x))]\n    (Integer/parseInt n)\n    0))\n')),(0,s.kt)("p",null,"Here is a function to extract the data points we mentioned at start from each item:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-clojure"},'(defn extract-item-from-hickory [el]\n  {:hacker-news.item/age            (class-text el "age")\n   :hacker-news.item/author-name    (class-text el "hnuser")\n   :hacker-news.item/comments-count (->> (hs/select (hs/find-in-text #"comments$") el)\n                                         first\n                                         (find-text)\n                                         (select-number))\n   :hacker-news.item/score          (select-number (class-text el "score"))\n   :hacker-news.item/id             (->> el :content first :attrs :id)\n   :hacker-news.item/rank-in-page   (select-number (class-text el "rank"))\n   :hacker-news.item/source         (class-text el "sitestr")\n   :hacker-news.item/title          (class-text el "titlelink")\n   :hacker-news.item/url            (->> (hs/select (hs/class "titlelink") el)\n                                         first :attrs :href)})\n')),(0,s.kt)("p",null,"Let's use it to extract the data from our previous process:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-clojure"},'(comment\n  (->> sample-html\n       (hc/parse)\n       (hc/as-hickory)\n       (hs/select (hs/class "itemlist"))\n       first\n       (hs/select (hs/and\n                    (hs/tag "tr")\n                    (hs/not (hs/or\n                              (hs/class "spacer")\n                              (hs/class "morespace")))))\n       (partition 2)\n       (mapv #(hash-map :type :element :tag :tbody :content (vec %)))\n       (mapv extract-item-from-hickory)))\n')),(0,s.kt)("p",null,"Now you should see the nice plain data in the output, with one map for each\nitem entry."),(0,s.kt)("h2",{id:"make-a-resolver"},"Make a resolver"),(0,s.kt)("p",null,"Time to introduce Pathom, now I'm going to turn that exploration code in a resolver:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-clojure",metastring:"{2-4,47-87}","{2-4,47-87}":!0},'(ns com.wsscode.pathom3.docs.demos.tutorials.hacker-news-scrapper\n  (:require [com.wsscode.pathom3.connect.indexes :as pci]\n            [com.wsscode.pathom3.connect.operation :as pco]\n            [com.wsscode.pathom3.interface.eql :as p.eql]\n            [hickory.core :as hc]\n            [hickory.select :as hs]))\n\n(defn find-text\n  "Given an element, traverse the contents until it reaches some text."\n  [el]\n  (loop [item (first (:content el))]\n    (if (string? item)\n      item\n      (if-let [next (some-> item :content first)]\n        (recur next)\n        nil))))\n\n(defn class-text\n  "Get the text for a given element that matches a css class."\n  [el class]\n  (->> (hs/select (hs/class class) el)\n       first\n       (find-text)))\n\n(defn select-number\n  "Extract the first integer from a string."\n  [x]\n  (if-let [[_ n] (re-find #"(\\d+)" (str x))]\n    (Integer/parseInt n)\n    0))\n\n(defn extract-item-from-hickory [el]\n  {:hacker-news.item/age            (class-text el "age")\n   :hacker-news.item/author-name    (class-text el "hnuser")\n   :hacker-news.item/comments-count (->> (hs/select (hs/find-in-text #"comments$") el)\n                                         first\n                                         (find-text)\n                                         (select-number))\n   :hacker-news.item/score          (select-number (class-text el "score"))\n   :hacker-news.item/id             (->> el :content first :attrs :id)\n   :hacker-news.item/rank-in-page   (select-number (class-text el "rank"))\n   :hacker-news.item/source         (class-text el "sitestr")\n   :hacker-news.item/title          (class-text el "storylink")\n   :hacker-news.item/url            (->> (hs/select (hs/class "storylink") el)\n                                         first :attrs :href)})\n\n(pco/defresolver news-page-html-string []\n  {:hacker-news.page/news-raw-html\n   (slurp "https://news.ycombinator.com/news")})\n\n(pco/defresolver news-page [{:hacker-news.page/keys [news-raw-html]}]\n  {::pco/output\n   [{:hacker-news.page/news\n     [:hacker-news.item/age\n      :hacker-news.item/author-name\n      :hacker-news.item/id\n      :hacker-news.item/comments-count\n      :hacker-news.item/score\n      :hacker-news.item/rank-in-page\n      :hacker-news.item/source\n      :hacker-news.item/title\n      :hacker-news.item/url]}]}\n  {:hacker-news.page/news\n   (->> news-raw-html\n        (hc/parse)\n        (hc/as-hickory)\n        (hs/select (hs/class "itemlist"))\n        first\n        (hs/select (hs/and\n                     (hs/tag "tr")\n                     (hs/not (hs/or\n                               (hs/class "spacer")\n                               (hs/class "morespace")))))\n        (partition 2)\n        (mapv #(hash-map :type :element :tag :tbody :content (vec %)))\n        (mapv extract-item-from-hickory))})\n\n(def env\n  (pci/register\n    [news-page-html-string\n     news-page]))\n\n(comment\n  ; get the title of all the news\n  (p.eql/process env\n    [{:hacker-news.page/news\n      [:hacker-news.item/title]}]))\n')),(0,s.kt)("p",null,"Not much yet, but we gained the ability to filter pieces of the results."),(0,s.kt)("admonition",{type:"tip"},(0,s.kt)("p",{parentName:"admonition"},"Some editors like ",(0,s.kt)("a",{parentName:"p",href:"https://cursive-ide.com/"},"Cursive")," do highlight keywords when your\ncursor is over them. You can use this indication to see the inputs connecting with\noutputs in the editor.")),(0,s.kt)("h3",{id:"caching-the-request-for-development"},"Caching the request for development"),(0,s.kt)("p",null,"When we run the process now, it requests hacker news every time. For development\nit's useful if we can cache that to have a faster iteration."),(0,s.kt)("p",null,"You may have noticed I used a separated resolver to fetch the HTML string. We can make\nthis resolver use a durable cache to speed up the iteration:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-clojure"},'(pco/defresolver news-page-html-string []\n  ; define a custom cache store for this resolver\n  {::pco/cache-store ::durable-cache*}\n  {:hacker-news.page/news-raw-html\n   (slurp "https://news.ycombinator.com/news")})\n\n; defonce to have a durable cache, an atom with a map is a valid empty cache\n(defonce cache* (atom {}))\n\n(def env\n  ; add our cache to the environment\n  (-> {::durable-cache* cache*}\n      (pci/register\n        [news-page-html-string\n         news-page])))\n')),(0,s.kt)("p",null,"Now, if you keep running that expression, it only does the IO on the first time."),(0,s.kt)("admonition",{type:"tip"},(0,s.kt)("p",{parentName:"admonition"},"To clear the cache, run ",(0,s.kt)("inlineCode",{parentName:"p"},"(reset! cache* {})")," in the REPL.")),(0,s.kt)("h2",{id:"traversing-pagination"},"Traversing pagination"),(0,s.kt)("p",null,"So far, we only read the first page of the news, but there is a ",(0,s.kt)("inlineCode",{parentName:"p"},"More")," button at the\nend. Now we are going to scan through these pages."),(0,s.kt)("p",null,"First we need to adapt the resolver that loads the page html to accept a custom URL\nfor it:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-clojure"},'(pco/defresolver news-page-html-string [{:hacker-news.page/keys [news-page-url]}]\n  {::pco/cache-store ::durable-cache*\n   ::pco/input       [(pco/? :hacker-news.page/news-page-url)]}\n  {:hacker-news.page/news-raw-html\n   (slurp (or news-page-url "https://news.ycombinator.com/news"))})\n')),(0,s.kt)("p",null,"I used an ",(0,s.kt)("a",{parentName:"p",href:"/docs/resolvers#optional-inputs"},"optional input")," named ",(0,s.kt)("inlineCode",{parentName:"p"},":hacker-news.page/news-page-url")," to allow the\ncustomization, but still have a default."),(0,s.kt)("p",null,"To provide the data with the URL for the next page, I'll add a new resolver. This resolver\nwill expose the attribute ",(0,s.kt)("inlineCode",{parentName:"p"},":hacker-news.page/news-next-page")," that contains the key\n",(0,s.kt)("inlineCode",{parentName:"p"},":hacker-news.page/news-page-url"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-clojure"},'(pco/defresolver news-next-page [{:hacker-news.page/keys [news-raw-html]}]\n  {::pco/output\n   [{:hacker-news.page/news-next-page\n     [:hacker-news.page/news-page-url]}]}\n  (let [link (some->> news-raw-html hc/parse hc/as-hickory\n               (hs/select (hs/class "morelink"))\n               first :attrs :href)]\n    (if link\n      {:hacker-news.page/news-next-page\n       {:hacker-news.page/news-page-url\n        (str "https://news.ycombinator.com/" link)}})))\n')),(0,s.kt)("admonition",{type:"tip"},(0,s.kt)("p",{parentName:"admonition"},"You can look at this resolver as an implementation of a linked list. The attribute\n",(0,s.kt)("inlineCode",{parentName:"p"},":hacker-news.page/news-next-page")," is a link to the next page item. In terms of Pathom,\nwe make that happen by providing the ",(0,s.kt)("inlineCode",{parentName:"p"},":hacker-news.page/news-page-url")," in that context, which can navigate\nto the next ",(0,s.kt)("inlineCode",{parentName:"p"},":hacker-news.page/news-next-page")," and so on...")),(0,s.kt)("p",null,"I check if there is a ",(0,s.kt)("inlineCode",{parentName:"p"},"More")," link. Otherwise, we don't return any data to tell Pathom\nthis is unavailable."),(0,s.kt)("p",null,"You may notice we now have two resolvers that get the HTML string for the news page\nand parse it. Each resolver is doing its parsing. We can make them share this\nby breaking this step into a new resolver."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-clojure",metastring:"{1-6,8-9,34-35}","{1-6,8-9,34-35}":!0},'; get the html string and compute hickory\n(pco/defresolver news-page-hickory [{:hacker-news.page/keys [news-raw-html]}]\n  {:hacker-news.page/news-hickory\n   (-> news-raw-html\n       (hc/parse)\n       (hc/as-hickory))})\n\n; news page now uses the hickory\n(pco/defresolver news-page [{:hacker-news.page/keys [news-hickory]}]\n  {::pco/output\n   [{:hacker-news.page/news\n     [:hacker-news.item/age\n      :hacker-news.item/author-name\n      :hacker-news.item/id\n      :hacker-news.item/comments-count\n      :hacker-news.item/score\n      :hacker-news.item/rank-in-page\n      :hacker-news.item/source\n      :hacker-news.item/title\n      :hacker-news.item/url]}]}\n  {:hacker-news.page/news\n   (->> news-hickory\n        (hs/select (hs/class "itemlist"))\n        first\n        (hs/select (hs/and\n                     (hs/tag "tr")\n                     (hs/not (hs/or\n                               (hs/class "spacer")\n                               (hs/class "morespace")))))\n        (partition 2)\n        (mapv #(hash-map :type :element :tag :tbody :content (vec %)))\n        (mapv extract-item-from-hickory))})\n\n; same for next page\n(pco/defresolver news-next-page [{:hacker-news.page/keys [news-hickory]}]\n  {::pco/output\n   [{:hacker-news.page/news-next-page\n     [:hacker-news.page/news-page-url]}]}\n\n  (let [link (some->> news-hickory\n               (hs/select (hs/class "morelink"))\n               first :attrs :href)]\n    (if link\n      {:hacker-news.page/news-next-page\n       {:hacker-news.page/news-page-url\n        (str "https://news.ycombinator.com/" link)}})))\n')),(0,s.kt)("p",null,"This is a crucial design choice when you write Pathom resolvers. How much you want\nto break, as you add more resolvers, you expand the connection points to other resolvers."),(0,s.kt)("p",null,"In general, it is a good practice to keep spread, but it's fine to provide many items\nin a resolver when they share a close process. This reduces the amount of work Pathom\nhas to do to integrate."),(0,s.kt)("p",null,"Let's play with our new resolvers:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-clojure",metastring:"{6,8}","{6,8}":!0},"; remember to update env to include all resolvers\n(def env\n  (-> {::durable-cache* cache*}\n      (pci/register\n        [news-page-html-string\n         news-page-hickory\n         news-page\n         news-next-page])))\n\n(comment\n  ; get titles from first and second page\n  (p.eql/process env\n    [{:hacker-news.page/news\n      [:hacker-news.item/title]}\n     {:hacker-news.page/news-next-page\n      [{:hacker-news.page/news\n        [:hacker-news.item/title]}]}]))\n")),(0,s.kt)("p",null,"Notice the query inside ",(0,s.kt)("inlineCode",{parentName:"p"},":hacker-news.page/news-next-page")," is the same used in the\nparent query. For this we can use recursive queries, let's say we want to pull the\nnext three pages:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-clojure"},"(comment\n  (p.eql/process env\n    [{:hacker-news.page/news\n      [:hacker-news.item/title]}\n     ; recurse bounded to 3 steps\n     {:hacker-news.page/news-next-page 3}]))\n")),(0,s.kt)("p",null,"How cool is that?! You may be saying now: ok, but that's a weird tree output."),(0,s.kt)("p",null,"To flat the items out we can use ",(0,s.kt)("inlineCode",{parentName:"p"},"tree-seq"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-clojure"},"(comment\n  (->> (p.eql/process env\n         [{:hacker-news.page/news\n           [:hacker-news.item/title]}\n          ; recurse bounded to 3 steps\n          {:hacker-news.page/news-next-page 3}])\n       (tree-seq :hacker-news.page/news-next-page\n         ; we need vector at the end because tree-seq expects children to be a collection\n         (comp vector :hacker-news.page/news-next-page))\n       ; mapcat the news to have a single flat list\n       (into [] (mapcat :hacker-news.page/news))))\n")),(0,s.kt)("admonition",{type:"note"},(0,s.kt)("p",{parentName:"admonition"},"Recursive queries can be numbers (bounded) or a symbol ... (unbounded). If you use the\nunbounded, it will pull pages until Hacker News is over with them. During the time\nI tested there were 21 pages. If you try, it may take some time to finish.")),(0,s.kt)("p",null,"Pathom also supports ",(0,s.kt)("a",{parentName:"p",href:"/docs/resolvers#nested-inputs"},"nested inputs"),", this means we can create a resolver to make that\nsame process we did with the query before:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-clojure",metastring:"{12-13}","{12-13}":!0},"(pco/defresolver all-news-pages [input]\n  {::pco/input  [{:hacker-news.page/news\n                  [:hacker-news.item/age\n                   :hacker-news.item/author-name\n                   :hacker-news.item/id\n                   :hacker-news.item/comments-count\n                   :hacker-news.item/score\n                   :hacker-news.item/rank-in-page\n                   :hacker-news.item/source\n                   :hacker-news.item/title\n                   :hacker-news.item/url]}\n                 ; note the recursive query here\n                 {:hacker-news.page/news-next-page '...}]\n   ::pco/output [{:hacker-news.page/news-all-pages\n                  [:hacker-news.item/age\n                   :hacker-news.item/author-name\n                   :hacker-news.item/id\n                   :hacker-news.item/comments-count\n                   :hacker-news.item/score\n                   :hacker-news.item/rank-in-page\n                   :hacker-news.item/source\n                   :hacker-news.item/title\n                   :hacker-news.item/url]}]}\n  {:hacker-news.page/news-all-pages\n   (->> input\n        (tree-seq :hacker-news.page/news-next-page\n          (comp vector :hacker-news.page/news-next-page))\n        (into [] (mapcat :hacker-news.page/news)))})\n")),(0,s.kt)("p",null,"Now we can, for example, make this query to read all titles in news, in all pages:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-clojure"},"(comment\n  ; this can take a while\n  (->> (p.eql/process env\n         [{:hacker-news.page/news-all-pages\n           [:hacker-news.item/title]}])))\n")),(0,s.kt)("h2",{id:"read-user-data"},"Read user data"),(0,s.kt)("p",null,"Let's look at the user page this time:"),(0,s.kt)("div",{className:"pathom-diagram"},(0,s.kt)("p",null,"  ",(0,s.kt)("img",{alt:"User Page Mapping",src:t(5063).Z,width:"668",height:"285"}))),(0,s.kt)("p",null,"Similar to before, but this time we require some user id to load the page. The arrows\nshow that the same attribute we read on the page as ",(0,s.kt)("inlineCode",{parentName:"p"},":hacker-news.user/id")," is used\nin the URL to load the page."),(0,s.kt)("p",null,"Here are the resolvers to parse this:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-clojure"},'(pco/defresolver user-data-hickory [{:keys [hacker-news.user/id]}]\n  ; also use the durable cache here\n  {::pco/cache-store ::durable-cache*}\n  {:hacker-news.page/user-hickory\n   (some-> (slurp (str "https://news.ycombinator.com/user?id=" id))\n     hc/parse hc/as-hickory)})\n\n(pco/defresolver user-data [{:hacker-news.page/keys [user-hickory]}]\n  {:hacker-news.user/karma\n   (->> user-hickory\n        (hs/select\n          (hs/and\n            (hs/tag "tr")\n            (hs/has-child (hs/find-in-text #"karma:"))))\n        first :content second :content select-number)\n\n   :hacker-news.user/join-date\n   (let [str (->> user-hickory\n                  (hs/select\n                    (hs/and\n                      (hs/tag "tr")\n                      (hs/has-child (hs/find-in-text #"created:"))))\n                  first :content second :content first :attrs :href)\n         [_ date] (re-find #"(\\d{4}-\\d{2}-\\d{2})" str)]\n     date)})\n')),(0,s.kt)("p",null,"Note we also use the durable cache, so we can keep playing it. When I created this I\nwas hitting the same cache entry until I got the extraction code right."),(0,s.kt)("admonition",{type:"important"},(0,s.kt)("p",{parentName:"admonition"},"You may have noticed that we now have two different attributes that mean user id.\nWe have ",(0,s.kt)("inlineCode",{parentName:"p"},":hacker-news.item/author-name")," and now ",(0,s.kt)("inlineCode",{parentName:"p"},":hacker-news.user/id"),". If we try to load the karma for the user in the HN item, it won't be able to get there."),(0,s.kt)("p",{parentName:"admonition"},"One idea is to change our previous resolver and rename ",(0,s.kt)("inlineCode",{parentName:"p"},":hacker-news.item/author-name"),"\nto ",(0,s.kt)("inlineCode",{parentName:"p"},":hacker-news.user/id"),". This would work, but this reduces the accuracy of this name\nsemantics. ",(0,s.kt)("inlineCode",{parentName:"p"},":hacker-news.item/author-name")," has a precise meaning. It's the author's\nname in an item."),(0,s.kt)("p",{parentName:"admonition"},"To reconcile this situation, we can create an ",(0,s.kt)("a",{parentName:"p",href:"/docs/built-in-resolvers#aliasing"},"alias-resolver"),",\nthat allows Pathom to navigate from one name to another. This is what I'm going to\nuse next."),(0,s.kt)("p",{parentName:"admonition"},"It's also good to point out that aliases are directional. We are allowing\n",(0,s.kt)("inlineCode",{parentName:"p"},":hacker-news.item/author-name")," to be translated in ",(0,s.kt)("inlineCode",{parentName:"p"},":hacker-news.user/id"),", but not\nthe reverse.")),(0,s.kt)("p",null,"Let's see who has the most karma from the front-page:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-clojure"},"; update env\n(def env\n  (-> {::durable-cache* cache*}\n      (pci/register\n        [; alias the author name to id\n         (pbir/alias-resolver :hacker-news.item/author-name :hacker-news.user/id)\n         news-page-html-string\n         news-page-hickory\n         news-page\n         news-next-page\n         user-data-hickory\n         user-data])))\n\n(comment\n  (->> (p.eql/process env\n         [{:hacker-news.page/news\n           [:hacker-news.item/author-name\n            :hacker-news.user/karma]}])\n       :hacker-news.page/news\n       (sort-by :hacker-news.user/karma #(compare %2 %))))\n")),(0,s.kt)("h2",{id:"read-comments"},"Read comments"),(0,s.kt)("p",null,"Let's map the comments section:"),(0,s.kt)("div",{className:"pathom-diagram"},(0,s.kt)("p",null,"  ",(0,s.kt)("img",{alt:"Comments Page Mapping",src:t(7641).Z,width:"1065",height:"899"}))),(0,s.kt)("p",null,"We can see at the top we have almost the same data as we did on the news list, except\nthe rank position (which makes sense since it's relative to that page)."),(0,s.kt)("p",null,"Let's start writing a resolver that can read this information given some item id:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-clojure"},'; load page as hickory, use our durable cache\n(pco/defresolver item-page-hickory [{:hacker-news.item/keys [id]}]\n  {::pco/cache-store ::durable-cache*}\n  {:hacker-news.page/item-hickory\n   (->> (slurp (str "https://news.ycombinator.com/item?id=" id))\n        hc/parse hc/as-hickory)})\n\n(pco/defresolver item-data [{:hacker-news.page/keys [item-hickory]}]\n  {::pco/output\n   [:hacker-news.item/age\n    :hacker-news.item/author-name\n    :hacker-news.item/comments-count\n    :hacker-news.item/score\n    :hacker-news.item/source\n    :hacker-news.item/title\n    :hacker-news.item/url]}\n  ; let\'s re-use our same extraction function, fatitem class is the container at\n  ; this page\n  (extract-item-from-hickory (->> (hs/select (hs/class "fatitem") item-hickory)\n                                  first)))\n')),(0,s.kt)("p",null,"That's easy enough\u2014time for the comments."),(0,s.kt)("p",null,"By looking at the page we can see comments are nested, and altough this example isn't\nshowing, they also support deep nesting."),(0,s.kt)("p",null,"Most of the time, the HTML will follow the structure of the data, but this isn't the\ncase here."),(0,s.kt)("p",null,"Try inspecting the page. You will see they use a flat table and manually add the\nspacings to convey the nesting."),(0,s.kt)("p",null,"This means we need to do more work to reconstruct the tree from a flat structure."),(0,s.kt)("p",null,"Let's do that in parts. First, let's extract it in a closer way to what we have: a flat structure. On top of the data I mentioned in the image, we now will\nalso add a ",(0,s.kt)("inlineCode",{parentName:"p"},":hacker-news.comment/ident"),", which tells us the row's indentation level. Later I'll use this to transform the list into a tree."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-clojure"},'(defn comment-ident-level [el]\n  (-> (hs/select (hs/and (hs/tag "img") (hs/attr "src" #{"s.gif"})) el)\n      first :attrs :width select-number (/ 40)))\n\n(defn extract-comment [el]\n  {:hacker-news.comment/id          (-> el :attrs :id)\n   :hacker-news.comment/age         (class-text el "age")\n   :hacker-news.comment/author-name (class-text el "hnuser")\n   :hacker-news.comment/indent      (comment-ident-level el)\n   :hacker-news.comment/content     (->> (hs/select (hs/class "comment") el)\n                                         first :content (keep find-text) (str/join "\\n"))})\n\n(pco/defresolver item-comments-flat [{:hacker-news.page/keys [item-hickory]}]\n  {::pco/output [{:hacker-news.item/comments-flat\n                  [:hacker-news.comment/author-name\n                   :hacker-news.comment/age\n                   :hacker-news.comment/content\n                   :hacker-news.comment/id\n                   :hacker-news.comment/indent]}]}\n  {:hacker-news.item/comments-flat\n   (->> item-hickory\n        (hs/select (hs/class "comtr"))\n        (mapv extract-comment))})\n')),(0,s.kt)("p",null,"We can test that with (remember to add all resolvers to the env):"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-clojure"},'(comment\n  ; get all comments author names\n  (p.eql/process env\n    {:hacker-news.item/id "25733200"}\n    [{:hacker-news.item/comments-flat\n      [:hacker-news.comment/author-name]}]))\n')),(0,s.kt)("p",null,"Now it's time to transform the list into a tree."),(0,s.kt)("p",null,"To think about this process, let's use make up some example data and how it should be\ntransformed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-clojure"},"; first, visually, it looks like this:\n; 1\n; | 2\n; | 3\n; 4\n; | 5\n; | | 6\n\n; we have a list like this, with ids and indentations, the rest of the data we can ignore\n; for the purpose of this transformation\n[{:id 1 :ident 0}\n {:id 2 :ident 1}\n {:id 3 :ident 1}\n {:id 4 :ident 0}\n {:id 5 :ident 1}\n {:id 6 :ident 2}]\n\n; and our goal is to transform that into:\n[{:id 1\n  :children [{:id 2}\n             {:id 3}]}\n {:id 4\n  :children [{:id 5\n              :children [{:id 6}]}]}]\n")),(0,s.kt)("p",null,"To do this, we have to go over the list and remember past items. My idea to remember the\ncurrent level is: When it goes up, add an item to a stack. When it goes down, remove it from the\nstack. The stack will contain the ids of the parent items. As I scan, I'll also add\nthe items to a list, indexed by ID. This way, I can modify any item at any time with ease."),(0,s.kt)("p",null,"I decided it would be fun to use Pathom as part of this process too, and it's nice the\nthings I discussed already feel like a graph."),(0,s.kt)("p",null,"This is the code:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-clojure"},"(pco/defresolver item-comments [{:hacker-news.item/keys [comments-flat]}]\n  {::pco/output\n   [{:hacker-news.item/comments\n     [:hacker-news.comment/author-name\n      :hacker-news.comment/age\n      :hacker-news.comment/content\n      :hacker-news.comment/id\n      {:hacker-news.comment/responses '...}]}]}\n  (let [{:keys [roots index]}\n        (->> comments-flat\n             (reduce\n               (fn [{:keys [level prev] :as acc} {:hacker-news.comment/keys [id indent] :as comment}]\n                 (let [{:keys [stack] :as acc} (cond-> acc\n                                                 (> indent level)\n                                                 (update :stack conj prev)\n\n                                                 (< indent level)\n                                                 (update :stack pop))\n                       stack-head (peek stack)]\n                   (cond-> acc\n                     true\n                     (-> (update :index assoc id comment)\n                         (assoc :level indent)\n                         (assoc :prev id))\n\n                     (zero? indent)\n                     (update :roots conj comment)\n\n                     (pos? indent)\n                     (update-in [:index stack-head :hacker-news.comment/responses]\n                       coll/vconj {:hacker-news.comment/id id}))))\n               {:stack []\n                :roots []\n                :index {}\n                :level 0\n                :prev  nil}))]\n    ; empty index when there are no comments\n    (if (seq index)\n      ; use pathom to transform the query in a tree\n      (->> (p.eql/process\n             (pci/register [(pbir/static-table-resolver :hacker-news.comment/id index)\n                            (pbir/constantly-resolver :roots roots)])\n             [{:roots [:hacker-news.comment/author-name\n                       :hacker-news.comment/age\n                       :hacker-news.comment/content\n                       :hacker-news.comment/id\n                       {:hacker-news.comment/responses '...}]}])\n           :roots\n           ; always remember to wrap the sequence in the named output\n           (hash-map :hacker-news.item/comments))\n      {:hacker-news.item/comments []})))\n")),(0,s.kt)("p",null,"Usage demo:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-clojure"},'; lets recap what our env is like with all of the things\n(def env\n  (-> {::durable-cache* cache*}\n      (pci/register\n        [(pbir/alias-resolver :hacker-news.item/author-name :hacker-news.user/id)\n         ; add this new one to also alias from comment author name\n         (pbir/alias-resolver :hacker-news.comment/author-name :hacker-news.user/id)\n         news-page-html-string\n         news-page-hickory\n         news-page\n         news-next-page\n         all-news-pages\n         user-data-hickory\n         user-data\n         item-page-hickory\n         item-data\n         item-comments-flat\n         item-comments])))\n\n(comment\n  ; the same we did before, but this time we will only see the top level comments\n  (p.eql/process env\n    {:hacker-news.item/id "25733200"}\n    [{:hacker-news.item/comments\n      [:hacker-news.comment/author-name]}]))\n\n(comment\n  ; now, get the whole structured comments, and also include the karma of each user\n  ; on it\n  (p.eql/process env\n    {:hacker-news.item/id "25733200"}\n    [{:hacker-news.item/comments\n      [:hacker-news.comment/author-name\n       :hacker-news.user/karma\n       {:hacker-news.comment/responses \'...}]}]))\n\n(comment\n  ; WARNING: this will trigger a lot of requests, may take some time. Also, HN may\n  ; throttle or block some accesses from you.\n  (p.eql/process env\n    [{:hacker-news.page/news\n      [:hacker-news.item/age\n       :hacker-news.item/author-name\n       :hacker-news.item/id\n       :hacker-news.item/comments-count\n       :hacker-news.item/score\n       :hacker-news.item/rank-in-page\n       :hacker-news.item/source\n       :hacker-news.item/title\n       :hacker-news.item/url\n\n       :hacker-news.user/id\n       :hacker-news.user/karma\n       :hacker-news.user/join-date\n\n       {:hacker-news.item/comments\n        [:hacker-news.comment/author-name\n         :hacker-news.comment/age\n         :hacker-news.comment/content\n         :hacker-news.comment/id\n\n         :hacker-news.user/id\n         :hacker-news.user/karma\n         :hacker-news.user/join-date\n\n         {:hacker-news.comment/responses \'...}]}]}]))\n')),(0,s.kt)("h2",{id:"playing-with-smart-maps"},"Playing with Smart Maps"),(0,s.kt)("p",null,"Let's do a pause on implementing HN things and play a bit with what we have."),(0,s.kt)("p",null,"In the previous examples we requested information using the ",(0,s.kt)("a",{parentName:"p",href:"/docs/eql"},"EQL interface"),". The\nEQL is the most efficient and precise way to use Pathom because in this way, Pathom\ncan look at a full-size request and optimize as much as possible."),(0,s.kt)("p",null,"I'll now introduce ",(0,s.kt)("a",{parentName:"p",href:"/docs/smart-maps"},"Smart Maps")," for our play here, which is a different interface to use\nPathom 3. Smart Maps are a data structure that works like Clojure maps, but when you\naccess some key that the map doesn't know the value, it uses the Pathom resolvers to\nfigure out (when possible)."),(0,s.kt)("p",null,"To this demo I'll start with some item id and fetch some data:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-clojure"},'(-> (psm/smart-map env {:hacker-news.item/id "25733200"})\n    :hacker-news.item/title)\n=> "OpenSocial Specification"\n')),(0,s.kt)("p",null,"Cool right?! You may be asking now: how do you know what is accessible?"),(0,s.kt)("p",null,"To answer that you can leverage the ",(0,s.kt)("inlineCode",{parentName:"p"},"datafy")," protocol implemented by Pathom Smart Maps:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-clojure"},'(-> (psm/smart-map env {:hacker-news.item/id "25733200"})\n    clojure.datafy/datafy)\n=>\n{:hacker-news.item/age :com.wsscode.pathom3.connect.operation/unknown-value\n :hacker-news.item/author-name :com.wsscode.pathom3.connect.operation/unknown-value\n :hacker-news.item/comments :com.wsscode.pathom3.connect.operation/unknown-value\n :hacker-news.item/comments-count :com.wsscode.pathom3.connect.operation/unknown-value\n :hacker-news.item/comments-flat :com.wsscode.pathom3.connect.operation/unknown-value\n :hacker-news.item/id "25733200"\n :hacker-news.item/score :com.wsscode.pathom3.connect.operation/unknown-value\n :hacker-news.item/source :com.wsscode.pathom3.connect.operation/unknown-value\n :hacker-news.item/title :com.wsscode.pathom3.connect.operation/unknown-value\n :hacker-news.item/url :com.wsscode.pathom3.connect.operation/unknown-value\n :hacker-news.page/item-hickory :com.wsscode.pathom3.connect.operation/unknown-value\n :hacker-news.page/news :com.wsscode.pathom3.connect.operation/unknown-value\n :hacker-news.page/news-all-pages :com.wsscode.pathom3.connect.operation/unknown-value\n :hacker-news.page/news-hickory :com.wsscode.pathom3.connect.operation/unknown-value\n :hacker-news.page/news-next-page :com.wsscode.pathom3.connect.operation/unknown-value\n :hacker-news.page/news-raw-html :com.wsscode.pathom3.connect.operation/unknown-value\n :hacker-news.page/user-hickory :com.wsscode.pathom3.connect.operation/unknown-value\n :hacker-news.user/id :com.wsscode.pathom3.connect.operation/unknown-value\n :hacker-news.user/join-date :com.wsscode.pathom3.connect.operation/unknown-value\n :hacker-news.user/karma :com.wsscode.pathom3.connect.operation/unknown-value}\n')),(0,s.kt)("p",null,"There we can see many attributes related to the item (given we provided an item id). Also,\nyou can see all the pages, and some user data (because of the relationship from item to\nthe user)."),(0,s.kt)("admonition",{type:"important"},(0,s.kt)("p",{parentName:"admonition"},"The options offered by the Smart Map datafy are contextual. This means if you change\nthe data you may get different possible paths.")),(0,s.kt)("p",null,"To some REPL play with it, here are some suggestions:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-clojure"},'; author karma from item 25733200\n(-> (psm/smart-map env {:hacker-news.item/id "25733200"})\n    :hacker-news.user/karma)\n\n; author and content of first comment of the first post on news\n(-> (psm/smart-map env {})\n    :hacker-news.page/news\n    first\n    :hacker-news.item/comments\n    first\n    (select-keys [:hacker-news.comment/author-name\n                  :hacker-news.comment/content\n                  :hacker-news.user/join-date]))\n')),(0,s.kt)("admonition",{type:"tip"},(0,s.kt)("p",{parentName:"admonition"},"Value responses to smart maps are also smart maps. This is what allows the navigation\nlike you have seen before. This also means you can datafy at any point to see what paths\nare available, for example:"),(0,s.kt)("pre",{parentName:"admonition"},(0,s.kt)("code",{parentName:"pre",className:"language-clojure"},"(-> (psm/smart-map env {})\n    :hacker-news.page/news\n    first\n    clojure.datafy/datafy)\n"))),(0,s.kt)("h2",{id:"other-pages"},"Other pages"),(0,s.kt)("p",null,"So far, we extracted some details and the news page. Other pages like ",(0,s.kt)("inlineCode",{parentName:"p"},"past")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"ask"),"\nare quite similar."),(0,s.kt)("p",null,"This is the list of resolvers we have to deal with on the news page:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-clojure"},"news-page-html-string\nnews-page-hickory\nnews-page\nnews-next-page\nall-news-pages\n")),(0,s.kt)("p",null,"For the ",(0,s.kt)("inlineCode",{parentName:"p"},"past")," page, I'll simplify that, make the same resolver request the HTML and\nparse it, as we did for comments and user details."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-clojure"},'(defn extract-items-from-list [hickory]\n  (let [tbody (->> hickory\n                   (hs/select (hs/class "itemlist"))\n                   first\n                   (hs/select (hs/tag "tbody"))\n                   first)\n        tbody (update tbody :content\n                #(into []\n                       (drop-while\n                         (fn [e]\n                           (let [cls (some-> e :attrs :class)]\n                             (not= cls "athing"))))\n                       %))]\n\n    (->> tbody\n         (hs/select (hs/and\n                      (hs/tag "tr")\n                      (hs/not (hs/or\n                                (hs/class "spacer")\n                                (hs/class "morespace")))))\n         (partition 2)\n         (mapv #(hash-map :type :element :tag :tbody :content (vec %)))\n         (mapv extract-item-from-hickory))))\n\n(defn extract-more-link [hickory]\n  (some->> hickory\n    (hs/select (hs/class "morelink"))\n    first :attrs :href))\n\n(pco/defresolver past-page-hickory [{:hacker-news.page/keys [past-page-url]}]\n  {::pco/cache-store ::durable-cache*\n   ::pco/input       [(pco/? :hacker-news.page/past-page-url)]}\n  {:hacker-news.page/past-hickory\n   (-> (or past-page-url "https://news.ycombinator.com/front")\n       slurp\n       (hc/parse)\n       (hc/as-hickory))})\n\n(pco/defresolver past-page [{:hacker-news.page/keys [past-hickory]}]\n  {::pco/output\n   [{:hacker-news.page/past\n     [:hacker-news.item/age\n      :hacker-news.item/author-name\n      :hacker-news.item/id\n      :hacker-news.item/comments-count\n      :hacker-news.item/score\n      :hacker-news.item/rank-in-page\n      :hacker-news.item/source\n      :hacker-news.item/title\n      :hacker-news.item/url]}]}\n  {:hacker-news.page/past\n   (extract-items-from-list past-hickory)})\n\n(pco/defresolver past-next-page [{:hacker-news.page/keys [past-hickory]}]\n  {::pco/output\n   [{:hacker-news.page/past-next-page\n     [:hacker-news.page/past-page-url]}]}\n\n  (if-let [link (extract-more-link past-hickory)]\n    {:hacker-news.page/past-next-page\n     {:hacker-news.page/past-page-url\n      (str "https://news.ycombinator.com/" link)}}))\n')),(0,s.kt)("p",null,"If we compare with the news resolvers, they are almost the same. The differences are:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"The resolver names are different"),(0,s.kt)("li",{parentName:"ul"},"The attribute names they are used for the collection node are different"),(0,s.kt)("li",{parentName:"ul"},"The initial page uses a different URL"),(0,s.kt)("li",{parentName:"ul"},"The table with items has some stuff before the actual first item. Our new implementation skips those.")),(0,s.kt)("p",null,"This similarity can make you feel like there is some higher-order thing to do here.\nEspecially when we consider that the ",(0,s.kt)("inlineCode",{parentName:"p"},"ask")," page will be another instance of the same\nsituation."),(0,s.kt)("p",null,"We can generalize this by writing a function that returns some resolvers, let's replace\nour ",(0,s.kt)("inlineCode",{parentName:"p"},"past")," page implementation with this idea:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-clojure"},'(defn hn-page-resolvers [page-name base-url]\n  (let [hickory-sym   (symbol "hacker-news.resolvers.page" (str page-name "-hickory"))\n        page-sym      (symbol "hacker-news.resolvers.page" page-name)\n        next-page-sym (symbol "hacker-news.resolvers.page" (str page-name "-next-page"))\n\n        hickory-kw    (keyword "hacker-news.page" (str page-name "-hickory"))\n        page-kw       (keyword "hacker-news.page" page-name)\n        next-page-kw  (keyword "hacker-news.page" (str page-name "-next-page"))\n        page-url-kw   (keyword "hacker-news.page" (str page-name "-page-url"))]\n    [(pco/resolver hickory-sym\n       {::pco/cache-store ::durable-cache*\n        ::pco/input       [(pco/? page-url-kw)]\n        ::pco/output      [hickory-kw]}\n       (fn [_ input]\n         {hickory-kw\n          (-> (or (get input page-url-kw) base-url)\n              slurp\n              (hc/parse)\n              (hc/as-hickory))}))\n\n     (pco/resolver page-sym\n       {::pco/input\n        [hickory-kw]\n\n        ::pco/output\n        [{page-kw\n          [:hacker-news.item/age\n           :hacker-news.item/author-name\n           :hacker-news.item/id\n           :hacker-news.item/comments-count\n           :hacker-news.item/score\n           :hacker-news.item/rank-in-page\n           :hacker-news.item/source\n           :hacker-news.item/title\n           :hacker-news.item/url]}]}\n       (fn [_ input]\n         {page-kw\n          (extract-items-from-list (get input hickory-kw))}))\n\n     (pco/resolver next-page-sym\n       {::pco/input\n        [hickory-kw]\n\n        ::pco/output\n        [{next-page-kw\n          [page-url-kw]}]}\n       (fn [_ input]\n\n         (if-let [link (extract-more-link (get input hickory-kw))]\n           {next-page-kw\n            {page-url-kw\n             (str "https://news.ycombinator.com/" link)}})))]))\n')),(0,s.kt)("p",null,"Now we have a function that returns 3 resolvers in a vector. We can now use this to\ndefine some pages:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-clojure",metastring:"{12-16}","{12-16}":!0},'(def env\n  (-> {::durable-cache* cache*}\n      (pci/register\n        [(pbir/alias-resolver :hacker-news.item/author-name :hacker-news.user/id)\n         (pbir/alias-resolver :hacker-news.comment/author-name :hacker-news.user/id)\n         news-page-html-string\n         news-page-hickory\n         news-page\n         news-next-page\n         all-news-pages\n\n         ; this is different than news, news is the home, newest are the most recent\n         (hn-page-resolvers "newest" "https://news.ycombinator.com/newest")\n         (hn-page-resolvers "past" "https://news.ycombinator.com/front")\n         (hn-page-resolvers "ask" "https://news.ycombinator.com/ask")\n         (hn-page-resolvers "show" "https://news.ycombinator.com/show")\n\n         user-data-hickory\n         user-data\n\n         item-page-hickory\n         item-data\n         item-comments-flat\n         item-comments])))\n')),(0,s.kt)("admonition",{type:"note"},(0,s.kt)("p",{parentName:"admonition"},(0,s.kt)("inlineCode",{parentName:"p"},"pci/register")," accepts nested vectors as definitions. It flattens the structure out\nin the process of registration.")),(0,s.kt)("p",null,"Just like that, we have four new pages implemented!"),(0,s.kt)("h2",{id:"review"},"Review"),(0,s.kt)("p",null,"That's it for this tutorial, a recap of what we saw here:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Design attribute names for Hacker News data"),(0,s.kt)("li",{parentName:"ul"},"Use Hickory to parse HTML data"),(0,s.kt)("li",{parentName:"ul"},"Create resolvers to connect the system"),(0,s.kt)("li",{parentName:"ul"},"Use recursive queries to traverse pagination"),(0,s.kt)("li",{parentName:"ul"},"Use optional inputs"),(0,s.kt)("li",{parentName:"ul"},"Use nested queries with recursive inputs"),(0,s.kt)("li",{parentName:"ul"},"Smart Maps exploration"),(0,s.kt)("li",{parentName:"ul"},"Creates resolvers dynamically using functions")),(0,s.kt)("p",null,"I hope you learned some new things about Pathom 3 in the process."),(0,s.kt)("p",null,"You can find the complete source code for this demo at: ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/wilkerlucio/pathom3-docs/blob/master/src/main/com/wsscode/pathom3/docs/demos/tutorials/hacker_news_scrapper.clj"},"https://github.com/wilkerlucio/pathom3-docs/blob/master/src/main/com/wsscode/pathom3/docs/demos/tutorials/hacker_news_scrapper.clj")),(0,s.kt)("h2",{id:"exercises"},"Exercises"),(0,s.kt)("p",null,"If you like to keep playing, here are some suggestions to add:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Parse comments back, linking back to the items they point to"),(0,s.kt)("li",{parentName:"ul"},"Make relationships from the user to its submissions, comments, and favorites"),(0,s.kt)("li",{parentName:"ul"},"Support logging in user and they use mutations to implement voting or submission of new entries"),(0,s.kt)("li",{parentName:"ul"},"Replace the HTML parsing implementation with the ",(0,s.kt)("a",{parentName:"li",href:"https://github.com/HackerNews/API"},"Hacker News API"))))}p.isMDXComponent=!0},7641:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/comments-page-mapping-e0b023e3af3f972a5fd5e566a8739918.png"},7065:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/front-page-mapping-d5349096bcb336297a94210c1ff2a0d9.png"},9281:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/inspect-container-649f80cfd60a317b395eb5fbacdd95cb.png"},5063:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/user-page-mapping-3391c9719602dcc5e58a29782de36eeb.png"}}]);