"use strict";(self.webpackChunkpathom_3_docs=self.webpackChunkpathom_3_docs||[]).push([[415],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>d});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},f=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),m=p(n),f=o,d=m["".concat(l,".").concat(f)]||m[f]||c[f]||i;return n?a.createElement(d,r(r({ref:t},u),{},{components:n})):a.createElement(d,r({ref:t},u))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=f;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[m]="string"==typeof e?e:o,r[1]=s;for(var p=2;p<i;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}f.displayName="MDXCreateElement"},6687:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var a=n(7462),o=(n(7294),n(3905));const i={title:"Mutations"},r=void 0,s={unversionedId:"mutations",id:"mutations",title:"Mutations",description:"Mutations are a mechanism to run procedures through EQL. For a syntax review please",source:"@site/docs/mutations.mdx",sourceDirName:".",slug:"/mutations",permalink:"/docs/mutations",draft:!1,editUrl:"https://github.com/wilkerlucio/pathom3-docs/edit/master/docs/mutations.mdx",tags:[],version:"current",frontMatter:{title:"Mutations"},sidebar:"docs",previous:{title:"Placeholders",permalink:"/docs/placeholders"},next:{title:"Error Handling",permalink:"/docs/error-handling"}},l={},p=[{value:"Using <code>defmutation</code>",id:"using-defmutation",level:2},{value:"Mutation joins",id:"mutation-joins",level:2},{value:"Changing mutation symbol",id:"changing-mutation-symbol",level:2},{value:"Resolve mutation params",id:"resolve-mutation-params",level:2}],u={toc:p},m="wrapper";function c(e){let{components:t,...n}=e;return(0,o.kt)(m,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Mutations are a mechanism to run procedures through EQL. For a syntax review please\ncheck the ",(0,o.kt)("a",{parentName:"p",href:"https://edn-query-language.org/eql/1.0.0/specification.html#_mutations"},"EQL Mutations specification"),"."),(0,o.kt)("h2",{id:"using-defmutation"},"Using ",(0,o.kt)("inlineCode",{parentName:"h2"},"defmutation")),(0,o.kt)("p",null,"To create mutations you can use the ",(0,o.kt)("inlineCode",{parentName:"p"},"defmutation")," helper, which is similar to the ",(0,o.kt)("inlineCode",{parentName:"p"},"defresolver")," macro. And similarly to resolvers,\nit can take a variable number of arguments - none, one (",(0,o.kt)("inlineCode",{parentName:"p"},"[parameters]"),"), or two (",(0,o.kt)("inlineCode",{parentName:"p"},"[env parameters]"),")."),(0,o.kt)("p",null,"Here is a mutation to save a file on disk:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-clojure"},"(pco/defmutation save-file [{::keys [file-path file-content] :as file}]\n  (spit file-path file-content)\n  file)\n")),(0,o.kt)("p",null,"Just like ",(0,o.kt)("inlineCode",{parentName:"p"},"defresolver"),", one difference here is that in mutations there is no ",(0,o.kt)("inlineCode",{parentName:"p"},"input"),",\nmutations always use ",(0,o.kt)("inlineCode",{parentName:"p"},"parameters"),"."),(0,o.kt)("p",null,"This is a subtle difference, but you can see it by inspecting the mutation:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-clojure"},"save-file\n=>\n; #com.wsscode.pathom3.connect.operation.Mutation\n;     {:config #:com.wsscode.pathom3.connect.operation\n;                  {:params  [:com.wsscode.pathom3.docs.mutations/file-path\n;                             :com.wsscode.pathom3.docs.mutations/file-content],\n;                   :op-name com.wsscode.pathom3.docs.mutations/save-file},\n;      :mutate #object[...]}\n")),(0,o.kt)("p",null,"Note what would be ",(0,o.kt)("inlineCode",{parentName:"p"},"::pco/input")," on a ",(0,o.kt)("inlineCode",{parentName:"p"},"defresolver"),", it's now ",(0,o.kt)("inlineCode",{parentName:"p"},"::pco/params")," in mutation."),(0,o.kt)("p",null,"Different from ",(0,o.kt)("inlineCode",{parentName:"p"},"inputs"),", parameters don't have auto-resolution, they always come as-is,\nbut having this information can help on creating extensions (to support auto-resolution\nif wanted) and help to understand the system (documentation)."),(0,o.kt)("p",null,"To run the mutation you need to use the ",(0,o.kt)("a",{parentName:"p",href:"/docs/eql"},"EQL")," interface:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-clojure"},'(def env (pci/register save-file))\n\n(p.eql/process env\n  [`(save-file {::file-path "./file.txt" ::file-content "contents here"})])\n; => {com.wsscode.pathom3.docs.mutations/save-file\n;     {:com.wsscode.pathom3.docs.mutations/file-path "./file.txt",\n;      :com.wsscode.pathom3.docs.mutations/file-content "contents here"}}\n')),(0,o.kt)("p",null,"The result of the mutation result comes in the same key as the mutation name."),(0,o.kt)("admonition",{type:"important"},(0,o.kt)("p",{parentName:"admonition"},"By default the mutation symbol is the fully qualified var name of the mutation. Note\nwe use the backtick to use the complete name.")),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"Mutations are the first thing the runner executes, this way you know the reads from\nthe query will have update values, in case the mutation affects something related to\nthem.")),(0,o.kt)("h2",{id:"mutation-joins"},"Mutation joins"),(0,o.kt)("p",null,"You can also make a join in the mutation to specify what you want from the result. For\nthis example we will write a resolver to get the file size, and use it as part of the\nmutation request:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-clojure",metastring:"{5-6,8,11-13}","{5-6,8,11-13}":!0},'(pco/defmutation save-file [{::keys [file-path file-content] :as file}]\n  (spit file-path file-content)\n  file)\n\n(pco/defresolver file-size [{::keys [file-path]}]\n  {::file-size (.length (io/file file-path))})\n\n(def env (pci/register [save-file file-size]))\n\n(p.eql/process env\n  [{`(save-file {::file-path "./file.txt" ::file-content "contents here"})\n    [::file-path\n     ::file-size]}])\n; => {com.wsscode.pathom3.docs.mutations/save-file\n;     {:com.wsscode.pathom3.docs.mutations/file-path "./file.txt",\n;      :com.wsscode.pathom3.docs.mutations/file-size 13}}\n')),(0,o.kt)("h2",{id:"changing-mutation-symbol"},"Changing mutation symbol"),(0,o.kt)("p",null,"I recommend sticking to fully qualified names, but in case you need a different name\nyou can use the ",(0,o.kt)("inlineCode",{parentName:"p"},"::pco/op-name")," to make it something else:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-clojure"},'(pco/defmutation save-file [{::keys [file-path file-content] :as file}]\n  {::pco/op-name \'io/save-my-file}\n  (spit file-path file-content)\n  file)\n\n; then you can use this name to call the mutation\n(p.eql/process env\n  [\'(io/save-my-file {::file-path "./file.txt" ::file-content "contents here"})])\n')),(0,o.kt)("h2",{id:"resolve-mutation-params"},"Resolve mutation params"),(0,o.kt)("p",null,"On Pathom, when you call a mutation, the params flow without any alteration. The default\nbehavior is meant to give the fastest path possible to invoke mutations."),(0,o.kt)("p",null,'That said, it\'s common also to want the params to be "resolved", just like Pathom does\nwith inputs on resolvers.'),(0,o.kt)("p",null,"To make that happen, you can use the ",(0,o.kt)("inlineCode",{parentName:"p"},"mutation-resolve-params")," built-in plugin. When\nyou add this plugin, Pathom will use the ",(0,o.kt)("inlineCode",{parentName:"p"},"::pco/params")," as a query and will run that\non the user params, and then deliver the resolved data to the mutation."),(0,o.kt)("p",null,"Example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-clojure"},"(pco/defmutation foo [{:keys [b]}]\n  {:res b})\n\n(p.eql/process\n  (-> (pci/register\n        [(pbir/single-attr-resolver :a :b inc)\n         foo])\n      (p.plugin/register pbip/mutation-resolve-params))\n  ['(foo {:a 1})])\n; => {foo {:res 2}}\n")),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"When using ",(0,o.kt)("inlineCode",{parentName:"p"},"pco/defmutation"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"::pco/params")," is inferred from the argument destructuring.")))}c.isMDXComponent=!0}}]);