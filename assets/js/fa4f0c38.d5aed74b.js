"use strict";(self.webpackChunkpathom_3_docs=self.webpackChunkpathom_3_docs||[]).push([[524],{3905:(e,t,n)=>{n.d(t,{kt:()=>d});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),m=p(n),d=r,g=m["".concat(l,".").concat(d)]||m[d]||u[d]||s;return n?a.createElement(g,i(i({ref:t},c),{},{components:n})):a.createElement(g,i({ref:t},c))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,i=new Array(s);i[0]=m;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[c]="string"==typeof e?e:r,i[1]=o;for(var p=2;p<s;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},5642:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>s,metadata:()=>o,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const s={title:"Built-in Resolvers"},i=void 0,o={unversionedId:"built-in-resolvers",id:"built-in-resolvers",title:"Built-in Resolvers",description:"Pathom comes with built-in resolvers to handle common situations. You will find these",source:"@site/docs/built-in-resolvers.mdx",sourceDirName:".",slug:"/built-in-resolvers",permalink:"/docs/built-in-resolvers",draft:!1,editUrl:"https://github.com/wilkerlucio/pathom3-docs/edit/master/docs/built-in-resolvers.mdx",tags:[],version:"current",frontMatter:{title:"Built-in Resolvers"},sidebar:"docs",previous:{title:"Resolvers",permalink:"/docs/resolvers"},next:{title:"Smart Maps",permalink:"/docs/smart-maps"}},l={},p=[{value:"Constants",id:"constants",level:2},{value:"Aliasing",id:"aliasing",level:2},{value:"Equivalence",id:"equivalence",level:2},{value:"Simple one-to-one transformation",id:"simple-one-to-one-transformation",level:2},{value:"Static Tables",id:"static-tables",level:2},{value:"Static Attribute Map",id:"static-attribute-map",level:2},{value:"Attribute Tables",id:"attribute-tables",level:2},{value:"Environment Tables",id:"environment-tables",level:2},{value:"EDN Files",id:"edn-files",level:2},{value:"Static tables on EDN Files",id:"static-tables-on-edn-files",level:3},{value:"Global Data",id:"global-data",level:2}],c={toc:p},u="wrapper";function m(e){let{components:t,...n}=e;return(0,r.kt)(u,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Pathom comes with built-in resolvers to handle common situations. You will find these\nresolver generators at:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clojure"},"[com.wsscode.pathom3.connect.built-in.resolvers :as pbir]\n")),(0,r.kt)("h2",{id:"constants"},"Constants"),(0,r.kt)("p",null,"This is a simple way to express a constant value for a given attribute."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clojure"},"(pbir/constantly-resolver :math/PI 3.1415)\n")),(0,r.kt)("p",null,"If instead of a constant value you want a function to generate the value, you can use\nthe ",(0,r.kt)("inlineCode",{parentName:"p"},"constantly-fn-resolver"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clojure"},'(pbir/constantly-fn-resolver ::throw-error (fn [_] (throw (ex-info "Error" {}))))\n')),(0,r.kt)("h2",{id:"aliasing"},"Aliasing"),(0,r.kt)("p",null,"You can use an alias to create a resolver that provides one attribute based on the same\nvalue as another:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clojure"},"(pbir/alias-resolver :specific.impl.product/id :generic.ui.product/id)\n\n; is equivalent to:\n\n(pco/defresolver spec->generic-prod-id [{:specific.impl.product/keys [id]}]\n  {:generic.ui.product/id id})\n")),(0,r.kt)("p",null,"Like the example suggests, you can use an alias to make some specific name and make it align\ngenerically with some other domain name."),(0,r.kt)("p",null,"Note that this only goes in one direction, to illustrate this, consider the extended\nexample here:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clojure"},"(def indexes\n  (pci/register\n    [specific-impl-registry\n     another-impl-option\n     (pbir/alias-resolver :specific.impl.product/id :generic.ui.product/id)\n     (pbir/alias-resolver :another.impl.product/id :generic.ui.product/id)]))\n")),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"A practical side of using this helper is that the helper will generate a name for the\nresolver for you, this alleviates the chore of repetitive writing and makes the alias\nnames look like each other. Try checking the resolver name for the alias resolvers\nfrom the previous example.")),(0,r.kt)("p",null,"In this case, both ",(0,r.kt)("inlineCode",{parentName:"p"},":specific.impl.product/id")," and ",(0,r.kt)("inlineCode",{parentName:"p"},":another.impl.product/id")," are valid\nvalue to show for ",(0,r.kt)("inlineCode",{parentName:"p"},":generic.ui.product/id"),"; but if you have only the ",(0,r.kt)("inlineCode",{parentName:"p"},":generic.ui.product/id"),",\nyou can't know if its from ",(0,r.kt)("inlineCode",{parentName:"p"},"specific")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"another")," impl."),(0,r.kt)("h2",{id:"equivalence"},"Equivalence"),(0,r.kt)("p",null,"Use this to express that two attributes are equivalent, that they share the same semantics.\nFor example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clojure"},"(pbir/equivalence-resolver :acme.product/upc :affiliate.product/upc)\n")),(0,r.kt)("p",null,"This is a common tool to integrate attributes from different domains."),(0,r.kt)("p",null,"In practice, it creates one alias resolver for each direction, any resolver that uses\nthe first will also work with the second, and vice versa."),(0,r.kt)("h2",{id:"simple-one-to-one-transformation"},"Simple one-to-one transformation"),(0,r.kt)("p",null,"This helper gives an easy way to convert one attribute into another, modified by a\nfunction. A common use case is to convert some attribute from one unit to another unit\nunder a different name. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clojure"},"; in this example we create one different transformation for each direction\n(def registry\n  [(pbir/single-attr-resolver :acme.track/duration-ms :affiliate.track/duration-seconds #(/ % 1000))\n   (pbir/single-attr-resolver :affiliate.track/duration-seconds :acme.track/duration-ms #(* % 1000))])\n\n(def indexes (pci/register registry))\n\n(-> (psm/smart-map indexes {:acme.track/duration-ms 324000})\n    :affiliate.track/duration-seconds)\n; => 324\n\n(-> (psm/smart-map indexes {:affiliate.track/duration-seconds 324})\n    :acme.track/duration-ms)\n; => 324000\n")),(0,r.kt)("p",null,"The function receives a single argument, which is the value of the ",(0,r.kt)("inlineCode",{parentName:"p"},"source")," attribute;\nand returns the value for ",(0,r.kt)("inlineCode",{parentName:"p"},"target")," attribute."),(0,r.kt)("p",null,"If your transformation also requires access to ",(0,r.kt)("inlineCode",{parentName:"p"},"env"),", use ",(0,r.kt)("inlineCode",{parentName:"p"},"single-attr-with-env-resolver"),"\ninstead, then the arglist of ",(0,r.kt)("inlineCode",{parentName:"p"},"f")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"[env input-attribute-value]"),"."),(0,r.kt)("h2",{id:"static-tables"},"Static Tables"),(0,r.kt)("p",null,"You can use static tables to provide extra data for some entities, given some identifier."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clojure"},'(def registry\n  [(pbir/static-table-resolver :song/id\n     {1 {:song/name "Marchinha Psicotica de Dr. Soup"}\n      2 {:song/name "There\'s Enough"}})\n\n   ; you can provide a name for the resolver, prefer fully qualified symbols\n   (pbir/static-table-resolver `song-analysis :song/id\n     {1 {:song/duration 280 :song/tempo 98}\n      2 {:song/duration 150 :song/tempo 130}})])\n\n(let [sm (psm/smart-map (pci/register registry)\n           {:song/id 1})]\n  (select-keys sm [:song/id :song/name :song/duration]))\n; => #:song{:id 1, :name "Marchinha Psicotica de Dr. Soup", :duration 280}\n')),(0,r.kt)("p",null,"This helper infers the output from the table data."),(0,r.kt)("h2",{id:"static-attribute-map"},"Static Attribute Map"),(0,r.kt)("p",null,"This one is similar to static tables, but to provide a single attribute for each entity\ninstead of many:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clojure"},'(def registry\n  [; simple attribute table\n   (pbir/static-attribute-map-resolver :song/id :song/name\n     {1 "Marchinha Psicotica de Dr. Soup"\n      2 "There\'s Enough"})\n\n   (pbir/static-table-resolver `song-analysis :song/id\n     {1 {:song/duration 280 :song/tempo 98}\n      2 {:song/duration 150 :song/tempo 130}})])\n\n(let [sm (psm/smart-map (pci/register registry)\n           {:song/id 1})]\n  (select-keys sm [:song/id :song/name :song/duration]))\n; => #:song{:id 1, :name "Marchinha Psicotica de Dr. Soup", :duration 280}\n')),(0,r.kt)("h2",{id:"attribute-tables"},"Attribute Tables"),(0,r.kt)("p",null,"This is also similar to static tables, but the table data comes from another attribute instead\nof static data."),(0,r.kt)("p",null,"Because in this case, the data is opaque, you need to express which keys will trigger\nthis table attribute lookup. This example is similar to the one from static tables, but\nwe will mix one static table with one attribute table this time."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clojure"},'(def registry\n  [(pbir/static-table-resolver `song-names :song/id\n     {1 {:song/name "Marchinha Psicotica de Dr. Soup"}\n      2 {:song/name "There\'s Enough"}})\n\n   ; provide table in the attribute ::song-analysis\n   (pbir/constantly-resolver ::song-analysis\n     {1 {:song/duration 280 :song/tempo 98}\n      2 {:song/duration 150 :song/tempo 130}})\n\n   ; ref the attribute, the index attribute and the output that triggers this resolver\n   (pbir/attribute-table-resolver ::song-analysis :song/id\n     [:song/duration :song/tempo])])\n\n(let [sm (psm/smart-map (pci/register registry)\n           {:song/id 2})]\n  (select-keys sm [:song/id :song/name :song/duration]))\n; => #:song{:id 2, :name "There\'s Enough", :duration 150}\n')),(0,r.kt)("h2",{id:"environment-tables"},"Environment Tables"),(0,r.kt)("p",null,"Environment tables are like attribute tables, but instead of looking for the table as\nan input, it looks for the table in the environment map."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clojure"},'(def registry\n  [(pbir/static-table-resolver `song-names :song/id\n     {1 {:song/name "Marchinha Psicotica de Dr. Soup"}\n      2 {:song/name "There\'s Enough"}})\n\n   (pbir/env-table-resolver ::song-analysis :song/id\n     [:song/duration :song/tempo])])\n\n(def song-details-table\n  {1 {:song/duration 280 :song/tempo 98}\n   2 {:song/duration 150 :song/tempo 130}})\n\n(let [sm (psm/smart-map (assoc (pci/register registry)\n                          ; add song-details-table to environment\n                          ::song-analysis song-details-table)\n           {:song/id 2})]\n  (select-keys sm [:song/id :song/name :song/duration]))\n; => #:song{:id 2, :name "There\'s Enough", :duration 150}\n')),(0,r.kt)("h2",{id:"edn-files"},"EDN Files"),(0,r.kt)("p",null,"Load attributes from an EDN file."),(0,r.kt)("p",null,"This is macro made to load some configuration from EDN at compilation time. It's an\neasy way to source some data from a file."),(0,r.kt)("p",null,"Basic example, given this configuration file:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clojure",metastring:'title="my-config.edn"',title:'"my-config.edn"'},'{:my.system.server/port\n 1234\n\n :my.system.resources/path\n "resources/public"}\n')),(0,r.kt)("p",null,"Loading with ",(0,r.kt)("inlineCode",{parentName:"p"},"edn-file-resolver"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clojure"},'; app\n(pco/defresolver full-url [{:keys [my.system.server/port my.system.resource/path]}]\n  {::server-url (str "http://localhost:" port "/" path)})\n\n(def registry\n  [(edn-file-resolver "my-config.edn")\n   full-url])\n\n(-> (psm/smart-map (pci/register registry))\n    ::server-url)\n; => "http://localhost:1234/resources/public\n')),(0,r.kt)("h3",{id:"static-tables-on-edn-files"},"Static tables on EDN Files"),(0,r.kt)("p",null,"You can also provide static tables as part of the EDN configuration. To do so, you\nadd the ",(0,r.kt)("inlineCode",{parentName:"p"},":com.wsscode.pathom3/entity-table")," key to the map meta, the value here defines\nwhich is the key to index the table data."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clojure",metastring:'title="my-config-with-table.edn"',title:'"my-config-with-table.edn"'},'{:my.system.server/port\n 1234\n\n :my.system.resources/path\n "resources/public"\n\n :my.system/generic-db\n ^{:com.wsscode.pathom3/entity-table :my.system/user-id}\n {4 {:my.system.user/name "Anne"}\n  2 {:my.system.user/name "Fred"}}}\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clojure"},'; app\n(def registry (edn-file-resolver "my-config.edn"))\n\n(let [sm (psm/smart-map (pci/register registry) {:my.system/user-id 4})]\n  (select-keys sm [:my.system/port :my.system.user/name]))\n; => {:my.system/port 1234, :my.system.user/name "Anne"}\n')),(0,r.kt)("admonition",{type:"important"},(0,r.kt)("p",{parentName:"admonition"},"Because this helper is a macro, it works on Clojurescript as well, but remember that\nit will pull the data from the EDN file at compilation time, not at runtime.")),(0,r.kt)("h2",{id:"global-data"},"Global Data"),(0,r.kt)("p",null,"Global data is the same operation that EDN Files do, but using the data directly:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clojure"},'; app\n(pco/defresolver full-url [{:keys [my.system.server/port my.system.resource/path]}]\n  {::server-url (str "http://localhost:" port "/" path)})\n\n(def registry\n  [(global-data-resolver {:my.system.server/port\n                          1234\n\n                          :my.system.resources/path\n                          "resources/public"})\n   full-url])\n\n(-> (psm/smart-map (pci/register registry))\n    ::server-url)\n; => "http://localhost:1234/resources/public\n')))}m.isMDXComponent=!0}}]);