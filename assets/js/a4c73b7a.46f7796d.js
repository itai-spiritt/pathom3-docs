"use strict";(self.webpackChunkpathom_3_docs=self.webpackChunkpathom_3_docs||[]).push([[350],{3905:(e,t,a)=>{a.d(t,{kt:()=>h});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var i=n.createContext({}),p=function(e){var t=n.useContext(i),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,i=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),c=p(a),h=r,d=c["".concat(i,".").concat(h)]||c[h]||m[h]||o;return a?n.createElement(d,l(l({ref:t},u),{},{components:a})):n.createElement(d,l({ref:t},u))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,l=new Array(o);l[0]=c;var s={};for(var i in t)hasOwnProperty.call(t,i)&&(s[i]=t[i]);s.originalType=e,s[u]="string"==typeof e?e:r,l[1]=s;for(var p=2;p<o;p++)l[p]=a[p];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},3449:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>i,contentTitle:()=>l,default:()=>c,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var n=a(7462),r=(a(7294),a(3905));const o={title:"GraphQL"},l=void 0,s={unversionedId:"integrations/graphql",id:"integrations/graphql",title:"GraphQL",description:"This page explains how Pathom consumes GraphQL services via dynamic resolvers",source:"@site/docs/integrations/graphql.mdx",sourceDirName:"integrations",slug:"/integrations/graphql",permalink:"/docs/integrations/graphql",draft:!1,editUrl:"https://github.com/wilkerlucio/pathom3-docs/edit/master/docs/integrations/graphql.mdx",tags:[],version:"current",frontMatter:{title:"GraphQL"},sidebar:"docs",previous:{title:"Shape Descriptor",permalink:"/docs/shape-descriptor"},next:{title:"Hacker News Scraper",permalink:"/docs/tutorials/hacker-news-scraper"}},i={},p=[{value:"How Pathom translates from GraphQL",id:"how-pathom-translates-from-graphql",level:2},{value:"Scalars",id:"scalars",level:3},{value:"Object Types",id:"object-types",level:3},{value:"Query Type",id:"query-type",level:3},{value:"Interfaces",id:"interfaces",level:3},{value:"Mutations",id:"mutations",level:3},{value:"Complete tutorial",id:"complete-tutorial",level:2}],u={toc:p},m="wrapper";function c(e){let{components:t,...a}=e;return(0,r.kt)(m,(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This page explains how Pathom consumes GraphQL services via ",(0,r.kt)("a",{parentName:"p",href:"/docs/dynamic-resolvers"},"dynamic resolvers")),(0,r.kt)("p",null,"Pathom consumers GraphQL by first adapting a GraphQL schema to the Pathom format. The\nfollow sections will explain how each part of GraphQL translates to Pathom."),(0,r.kt)("h2",{id:"how-pathom-translates-from-graphql"},"How Pathom translates from GraphQL"),(0,r.kt)("p",null,"It's important to remember that Pathom and GraphQL use different base abstraction ideas."),(0,r.kt)("p",null,"While GraphQL is based typed schema, Pathom works with attributes as the primary building blocks."),(0,r.kt)("p",null,"Let's take a look in an example to see what this translation look like, take the\nfollowing GraphQL schema as an example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"type Query {\n  me: User\n}\n\ntype User {\n  id: ID\n  name: String\n}\n")),(0,r.kt)("p",null,"When we connect to Pathom, it's required that you define a namespace to prefix all\nthe names that we will import from the GraphQL service."),(0,r.kt)("p",null,"For this example I'll pick the name ",(0,r.kt)("inlineCode",{parentName:"p"},'"gqldemo"'),", this is what the import code looks\nlike:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clojure"},'(p.gql/connect-graphql\n  {::p.gql/namespace "gqldemo"}\n  request-graphql-fn)\n')),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("h3",{parentName:"admonition",id:"the-request-function"},"The request function"),(0,r.kt)("p",{parentName:"admonition"},"The ",(0,r.kt)("inlineCode",{parentName:"p"},"request-graphql-fn")," must be a function that takes a GraphQL string as input and\noutput the GraphQL JSON results converted to Clojure data structures. It's important\nthat you use strings for the keys (not keywords).")),(0,r.kt)("p",null,"With that configuration, we should expect the following attributes to be available\nfrom Pathom:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clojure"},":gqldemo.Query/me\n:gqldemo.User/id\n:gqldemo.User/name\n")),(0,r.kt)("p",null,"An example query to fetch the name of the current user:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clojure"},"[{:gqldemo.Query/me\n  [:gqldemo.User/name]}]\n")),(0,r.kt)("h3",{id:"scalars"},"Scalars"),(0,r.kt)("p",null,"Pathom doesn't do anything about scalars, in the context of Pathom integration with\nGraphQL they are irrelevant."),(0,r.kt)("h3",{id:"object-types"},"Object Types"),(0,r.kt)("p",null,"For each object type in GraphQL, Pathom will add one attribute to hold the type itself\nand one attribute for each property of that type in GraphQL."),(0,r.kt)("p",null,"Getting back to our previous example, for the type ",(0,r.kt)("inlineCode",{parentName:"p"},"User")," we will have this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clojure"},"; type name\n:gqldemo.types/User\n\n; attributes for properties\n:gqldemo.User/id\n:gqldemo.User/name\n")),(0,r.kt)("p",null,"It's important to note that ",(0,r.kt)("inlineCode",{parentName:"p"},":gqldemo.types/User")," is marked as a transient attribute.\nThis means you can't query for it, but it's part of the query resolution."),(0,r.kt)("p",null,"Having these types named allow us to reference the type (which means we can access\nall attributes of it) in a simple way."),(0,r.kt)("h3",{id:"query-type"},"Query Type"),(0,r.kt)("p",null,"Query types are first defined in the same way as the object types. The special thing\nabout the Query type is that Pathom will make it accessible from anywhere, so you can\nenter the GraphQL from its properties."),(0,r.kt)("h3",{id:"interfaces"},"Interfaces"),(0,r.kt)("p",null,"From Pathom point of view, interfaces work backwards. Pathom will find all the\nimplementations of the interface and link them will all implementor object types."),(0,r.kt)("h3",{id:"mutations"},"Mutations"),(0,r.kt)("p",null,"All mutations are imported all namespaced by the user prefix plus ",(0,r.kt)("inlineCode",{parentName:"p"},".Mutation"),", for\nexample:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"type Mutation {\n  setMessage(message: String): String\n}\n")),(0,r.kt)("p",null,"Here is how we call it:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clojure"},'[(gqldemo.Mutation/setMessage {:message "Some message"})]\n')),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"The namespace at the mutation params are not relevant, with or without a namespace\nPathom will send them as-is.")),(0,r.kt)("p",null,"Depending on the mutation you may need to add a sub-query to satisfy the GraphQL\nsyntax."),(0,r.kt)("p",null,"Taking another example from GraphQL documentation:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"input MessageInput {\n  content: String\n  author: String\n}\n\ntype Message {\n  id: ID!\n  content: String\n  author: String\n}\n\ntype Query {\n  getMessage(id: ID!): Message\n}\n\ntype Mutation {\n  createMessage(input: MessageInput): Message\n  updateMessage(id: ID!, input: MessageInput): Message\n}\n")),(0,r.kt)("p",null,"Using the same prefix as before, this is how we can call createMessage:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clojure"},'[{(gqldemo.Mutation/createMessage {:id 123 :content "Some message" :author "Margaret"})\n  [:gqldemo.Message/id\n   :gqldemo.Message/content]}]\n')),(0,r.kt)("h2",{id:"complete-tutorial"},"Complete tutorial"),(0,r.kt)("p",null,"If you like to see a more complete integration example check the\n",(0,r.kt)("a",{parentName:"p",href:"/docs/tutorials/graphql-integration"},"GraphQL Tutorial"),"."))}c.isMDXComponent=!0}}]);